/-
Copyright (c) 2019 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import category_theory.functor

/-!
# Unbundled functors, as a typeclass decorating the object-level function.
-/

namespace category_theory

universes v v‚ÇÅ v‚ÇÇ v‚ÇÉ u u‚ÇÅ u‚ÇÇ u‚ÇÉ -- declare the `v`'s first; see `category_theory.category` for an explanation

variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D]

/-- A unbundled functor. -/
-- Perhaps in the future we could redefine `functor` in terms of this, but that isn't the
-- immediate plan.
class functorial (F : C ‚Üí D) : Type (max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ) :=
(map       : Œ† {X Y : C}, (X ‚ü∂ Y) ‚Üí ((F X) ‚ü∂ (F Y)))
(map_id'   : ‚àÄ (X : C), map (ùüô X) = ùüô (F X) . obviously)
(map_comp' : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map (f ‚â´ g) = (map f) ‚â´ (map g) . obviously)

restate_axiom functorial.map_id'
attribute [simp] functorial.map_id
restate_axiom functorial.map_comp'
attribute [simp] functorial.map_comp

/--
If `F : C ‚Üí D` (just a function) has `[functorial F]`,
we can write `map F f  : F X ‚ü∂ F Y` for the action of `F` on a morphism `f : X ‚ü∂ Y`.
-/
def map (F : C ‚Üí D) [functorial.{v‚ÇÅ v‚ÇÇ} F] {X Y : C} (f : X ‚ü∂ Y) : F X ‚ü∂ F Y :=
functorial.map.{v‚ÇÅ v‚ÇÇ} f

namespace functor

/--
Bundle a functorial function as a functor.
-/
def of (F : C ‚Üí D) [I : functorial.{v‚ÇÅ v‚ÇÇ} F] : C ‚•§ D :=
{ obj := F,
  ..I }

end functor

instance (F : C ‚•§ D) : functorial.{v‚ÇÅ v‚ÇÇ} (F.obj) := { .. F }

@[simp]
lemma map_functorial_obj (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) : map F.obj f = F.map f := rfl

instance functorial_id : functorial.{v‚ÇÅ v‚ÇÅ} (id : C ‚Üí C) :=
{ map := Œª X Y f, f }

section
variables {E : Type u‚ÇÉ} [category.{v‚ÇÉ} E]

/--
`G ‚àò F` is a functorial if both `F` and `G` are.
-/
-- This is no longer viable as an instance in Lean 3.7,
-- #lint reports an instance loop
-- Will this be a problem?
def functorial_comp (F : C ‚Üí D) [functorial.{v‚ÇÅ v‚ÇÇ} F] (G : D ‚Üí E) [functorial.{v‚ÇÇ v‚ÇÉ} G] :
  functorial.{v‚ÇÅ v‚ÇÉ} (G ‚àò F) :=
{ ..(functor.of F ‚ãô functor.of G) }

end

end category_theory
