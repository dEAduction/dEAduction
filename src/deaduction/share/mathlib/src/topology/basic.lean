/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Jeremy Avigad
-/
import order.filter.ultrafilter
import order.filter.partial
import order.filter.bases

/-!
# Basic theory of topological spaces.

The main definition is the type class `topological space Œ±` which endows a type `Œ±` with a topology.
Then `set Œ±` gets predicates `is_open`, `is_closed` and functions `interior`, `closure` and
`frontier`. Each point `x` of `Œ±` gets a neighborhood filter `ùìù x`. A filter `F` on `Œ±`¬†has
`x` as a cluster point if `is_cluster_pt x F : ùìù x ‚äì F ‚â† ‚ä•`. A map `f : Œπ ‚Üí Œ±` clusters at `x`
along `F : filter Œπ` if `map_cluster_pt x F f : cluster_pt x (map f F)`. In particular
the notion of cluster point of a sequence `u` is `map_cluster_pt x at_top u`.

This file also defines locally finite families of subsets of `Œ±`.

For topological spaces `Œ±` and `Œ≤`, a function `f : Œ± ‚Üí Œ≤` and a point `a : Œ±`,
`continuous_at f a` means `f` is continuous at `a`, and global continuity is
`continuous f`. There is also a version of continuity `pcontinuous` for
partially defined functions.

## Implementation notes

Topology in mathlib heavily uses filters (even more than in Bourbaki). See explanations in
<https://leanprover-community.github.io/theories/topology.html>.

## References

*  [N. Bourbaki, *General Topology*][bourbaki1966]
*  [I. M. James, *Topologies and Uniformities*][james1999]

## Tags

topological space, interior, closure, frontier, neighborhood, continuity, continuous function
-/

open set filter classical
open_locale classical filter

universes u v w

/-!
###¬†Topological spaces
-/

/-- A topology on `Œ±`. -/
@[protect_proj] structure topological_space (Œ± : Type u) :=
(is_open        : set Œ± ‚Üí Prop)
(is_open_univ   : is_open univ)
(is_open_inter  : ‚àÄs t, is_open s ‚Üí is_open t ‚Üí is_open (s ‚à© t))
(is_open_sUnion : ‚àÄs, (‚àÄt‚ààs, is_open t) ‚Üí is_open (‚ãÉ‚ÇÄ s))

attribute [class] topological_space

/-- A constructor for topologies by specifying the closed sets,
and showing that they satisfy the appropriate conditions. -/
def topological_space.of_closed {Œ± : Type u} (T : set (set Œ±))
  (empty_mem : ‚àÖ ‚àà T) (sInter_mem : ‚àÄ A ‚äÜ T, ‚ãÇ‚ÇÄ A ‚àà T) (union_mem : ‚àÄ A B ‚àà T, A ‚à™ B ‚àà T) :
  topological_space Œ± :=
{ is_open := Œª X, -X ‚àà T,
  is_open_univ := by simp [empty_mem],
  is_open_inter := Œª s t hs ht, by simpa [set.compl_inter] using union_mem (-s) (-t) hs ht,
  is_open_sUnion := Œª s hs,
    by rw set.compl_sUnion; exact sInter_mem (set.compl '' s)
    (Œª z ‚ü®y, hy, hz‚ü©, by simpa [hz.symm] using hs y hy) }

section topological_space

variables {Œ± : Type u} {Œ≤ : Type v} {Œπ : Sort w} {a : Œ±} {s s‚ÇÅ s‚ÇÇ : set Œ±} {p p‚ÇÅ p‚ÇÇ : Œ± ‚Üí Prop}

@[ext]
lemma topological_space_eq : ‚àÄ {f g : topological_space Œ±}, f.is_open = g.is_open ‚Üí f = g
| ‚ü®a, _, _, _‚ü© ‚ü®b, _, _, _‚ü© rfl := rfl

section
variables [t : topological_space Œ±]
include t

/-- `is_open s` means that `s` is open in the ambient topological space on `Œ±` -/
def is_open (s : set Œ±) : Prop := topological_space.is_open t s

@[simp]
lemma is_open_univ : is_open (univ : set Œ±) := topological_space.is_open_univ t

lemma is_open_inter (h‚ÇÅ : is_open s‚ÇÅ) (h‚ÇÇ : is_open s‚ÇÇ) : is_open (s‚ÇÅ ‚à© s‚ÇÇ) :=
topological_space.is_open_inter t s‚ÇÅ s‚ÇÇ h‚ÇÅ h‚ÇÇ

lemma is_open_sUnion {s : set (set Œ±)} (h : ‚àÄt ‚àà s, is_open t) : is_open (‚ãÉ‚ÇÄ s) :=
topological_space.is_open_sUnion t s h

end

lemma is_open_fold {s : set Œ±} {t : topological_space Œ±} : t.is_open s = @is_open Œ± t s :=
rfl

variables [topological_space Œ±]

lemma is_open_Union {f : Œπ ‚Üí set Œ±} (h : ‚àÄi, is_open (f i)) : is_open (‚ãÉi, f i) :=
is_open_sUnion $ by rintro _ ‚ü®i, rfl‚ü©; exact h i

lemma is_open_bUnion {s : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (h : ‚àÄi‚ààs, is_open (f i)) :
  is_open (‚ãÉi‚ààs, f i) :=
is_open_Union $ assume i, is_open_Union $ assume hi, h i hi

lemma is_open_union (h‚ÇÅ : is_open s‚ÇÅ) (h‚ÇÇ : is_open s‚ÇÇ) : is_open (s‚ÇÅ ‚à™ s‚ÇÇ) :=
by rw union_eq_Union; exact is_open_Union (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©)

@[simp] lemma is_open_empty : is_open (‚àÖ : set Œ±) :=
by rw ‚Üê sUnion_empty; exact is_open_sUnion (assume a, false.elim)

lemma is_open_sInter {s : set (set Œ±)} (hs : finite s) : (‚àÄt ‚àà s, is_open t) ‚Üí is_open (‚ãÇ‚ÇÄ s) :=
finite.induction_on hs (Œª _, by rw sInter_empty; exact is_open_univ) $
Œª a s has hs ih h, by rw sInter_insert; exact
is_open_inter (h _ $ mem_insert _ _) (ih $ Œª t, h t ‚àò mem_insert_of_mem _)

lemma is_open_bInter {s : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (hs : finite s) :
  (‚àÄi‚ààs, is_open (f i)) ‚Üí is_open (‚ãÇi‚ààs, f i) :=
finite.induction_on hs
  (Œª _, by rw bInter_empty; exact is_open_univ)
  (Œª a s has hs ih h, by rw bInter_insert; exact
    is_open_inter (h a (mem_insert _ _)) (ih (Œª i hi, h i (mem_insert_of_mem _ hi))))

lemma is_open_Inter [fintype Œ≤] {s : Œ≤ ‚Üí set Œ±}
  (h : ‚àÄ i, is_open (s i)) : is_open (‚ãÇ i, s i) :=
suffices is_open (‚ãÇ (i : Œ≤) (hi : i ‚àà @univ Œ≤), s i), by simpa,
is_open_bInter finite_univ (Œª i _, h i)

lemma is_open_Inter_prop {p : Prop} {s : p ‚Üí set Œ±}
  (h : ‚àÄ h : p, is_open (s h)) : is_open (Inter s) :=
by by_cases p; simp *

lemma is_open_const {p : Prop} : is_open {a : Œ± | p} :=
by_cases
  (assume : p, begin simp only [this]; exact is_open_univ end)
  (assume : ¬¨ p, begin simp only [this]; exact is_open_empty end)

lemma is_open_and : is_open {a | p‚ÇÅ a} ‚Üí is_open {a | p‚ÇÇ a} ‚Üí is_open {a | p‚ÇÅ a ‚àß p‚ÇÇ a} :=
is_open_inter

/-- A set is closed if its complement is open -/
def is_closed (s : set Œ±) : Prop := is_open (-s)

@[simp] lemma is_closed_empty : is_closed (‚àÖ : set Œ±) :=
by unfold is_closed; rw compl_empty; exact is_open_univ

@[simp] lemma is_closed_univ : is_closed (univ : set Œ±) :=
by unfold is_closed; rw compl_univ; exact is_open_empty

lemma is_closed_union : is_closed s‚ÇÅ ‚Üí is_closed s‚ÇÇ ‚Üí is_closed (s‚ÇÅ ‚à™ s‚ÇÇ) :=
Œª h‚ÇÅ h‚ÇÇ, by unfold is_closed; rw compl_union; exact is_open_inter h‚ÇÅ h‚ÇÇ

lemma is_closed_sInter {s : set (set Œ±)} : (‚àÄt ‚àà s, is_closed t) ‚Üí is_closed (‚ãÇ‚ÇÄ s) :=
by simp only [is_closed, compl_sInter, sUnion_image]; exact assume h, is_open_Union $ assume t, is_open_Union $ assume ht, h t ht

lemma is_closed_Inter {f : Œπ ‚Üí set Œ±} (h : ‚àÄi, is_closed (f i)) : is_closed (‚ãÇi, f i ) :=
is_closed_sInter $ assume t ‚ü®i, (heq : f i = t)‚ü©, heq ‚ñ∏ h i

@[simp] lemma is_open_compl_iff {s : set Œ±} : is_open (-s) ‚Üî is_closed s := iff.rfl

@[simp] lemma is_closed_compl_iff {s : set Œ±} : is_closed (-s) ‚Üî is_open s :=
by rw [‚Üêis_open_compl_iff, compl_compl]

lemma is_open_diff {s t : set Œ±} (h‚ÇÅ : is_open s) (h‚ÇÇ : is_closed t) : is_open (s \ t) :=
is_open_inter h‚ÇÅ $ is_open_compl_iff.mpr h‚ÇÇ

lemma is_closed_inter (h‚ÇÅ : is_closed s‚ÇÅ) (h‚ÇÇ : is_closed s‚ÇÇ) : is_closed (s‚ÇÅ ‚à© s‚ÇÇ) :=
by rw [is_closed, compl_inter]; exact is_open_union h‚ÇÅ h‚ÇÇ

lemma is_closed_bUnion {s : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (hs : finite s) :
  (‚àÄi‚ààs, is_closed (f i)) ‚Üí is_closed (‚ãÉi‚ààs, f i) :=
finite.induction_on hs
  (Œª _, by rw bUnion_empty; exact is_closed_empty)
  (Œª a s has hs ih h, by rw bUnion_insert; exact
    is_closed_union (h a (mem_insert _ _)) (ih (Œª i hi, h i (mem_insert_of_mem _ hi))))

lemma is_closed_Union [fintype Œ≤] {s : Œ≤ ‚Üí set Œ±}
  (h : ‚àÄ i, is_closed (s i)) : is_closed (Union s) :=
suffices is_closed (‚ãÉ (i : Œ≤) (hi : i ‚àà @univ Œ≤), s i),
  by convert this; simp [set.ext_iff],
is_closed_bUnion finite_univ (Œª i _, h i)

lemma is_closed_Union_prop {p : Prop} {s : p ‚Üí set Œ±}
  (h : ‚àÄ h : p, is_closed (s h)) : is_closed (Union s) :=
by by_cases p; simp *

lemma is_closed_imp {p q : Œ± ‚Üí Prop} (hp : is_open {x | p x})
  (hq : is_closed {x | q x}) : is_closed {x | p x ‚Üí q x} :=
have {x | p x ‚Üí q x} = (- {x | p x}) ‚à™ {x | q x}, from set.ext $ Œª x, imp_iff_not_or,
by rw [this]; exact is_closed_union (is_closed_compl_iff.mpr hp) hq

lemma is_open_neg : is_closed {a | p a} ‚Üí is_open {a | ¬¨ p a} :=
is_open_compl_iff.mpr

/-!
### Interior of a set
-/

/-- The interior of a set `s` is the largest open subset of `s`. -/
def interior (s : set Œ±) : set Œ± := ‚ãÉ‚ÇÄ {t | is_open t ‚àß t ‚äÜ s}

lemma mem_interior {s : set Œ±} {x : Œ±} :
  x ‚àà interior s ‚Üî ‚àÉ t ‚äÜ s, is_open t ‚àß x ‚àà t :=
by simp only [interior, mem_set_of_eq, exists_prop, and_assoc, and.left_comm]

@[simp] lemma is_open_interior {s : set Œ±} : is_open (interior s) :=
is_open_sUnion $ assume t ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h‚ÇÅ

lemma interior_subset {s : set Œ±} : interior s ‚äÜ s :=
sUnion_subset $ assume t ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h‚ÇÇ

lemma interior_maximal {s t : set Œ±} (h‚ÇÅ : t ‚äÜ s) (h‚ÇÇ : is_open t) : t ‚äÜ interior s :=
subset_sUnion_of_mem ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©

lemma interior_eq_of_open {s : set Œ±} (h : is_open s) : interior s = s :=
subset.antisymm interior_subset (interior_maximal (subset.refl s) h)

lemma interior_eq_iff_open {s : set Œ±} : interior s = s ‚Üî is_open s :=
‚ü®assume h, h ‚ñ∏ is_open_interior, interior_eq_of_open‚ü©

lemma subset_interior_iff_open {s : set Œ±} : s ‚äÜ interior s ‚Üî is_open s :=
by simp only [interior_eq_iff_open.symm, subset.antisymm_iff, interior_subset, true_and]

lemma subset_interior_iff_subset_of_open {s t : set Œ±} (h‚ÇÅ : is_open s) :
  s ‚äÜ interior t ‚Üî s ‚äÜ t :=
‚ü®assume h, subset.trans h interior_subset, assume h‚ÇÇ, interior_maximal h‚ÇÇ h‚ÇÅ‚ü©

lemma interior_mono {s t : set Œ±} (h : s ‚äÜ t) : interior s ‚äÜ interior t :=
interior_maximal (subset.trans interior_subset h) is_open_interior

@[simp] lemma interior_empty : interior (‚àÖ : set Œ±) = ‚àÖ :=
interior_eq_of_open is_open_empty

@[simp] lemma interior_univ : interior (univ : set Œ±) = univ :=
interior_eq_of_open is_open_univ

@[simp] lemma interior_interior {s : set Œ±} : interior (interior s) = interior s :=
interior_eq_of_open is_open_interior

@[simp] lemma interior_inter {s t : set Œ±} : interior (s ‚à© t) = interior s ‚à© interior t :=
subset.antisymm
  (subset_inter (interior_mono $ inter_subset_left s t) (interior_mono $ inter_subset_right s t))
  (interior_maximal (inter_subset_inter interior_subset interior_subset) $ is_open_inter is_open_interior is_open_interior)

lemma interior_union_is_closed_of_interior_empty {s t : set Œ±} (h‚ÇÅ : is_closed s) (h‚ÇÇ : interior t = ‚àÖ) :
  interior (s ‚à™ t) = interior s :=
have interior (s ‚à™ t) ‚äÜ s, from
  assume x ‚ü®u, ‚ü®(hu‚ÇÅ : is_open u), (hu‚ÇÇ : u ‚äÜ s ‚à™ t)‚ü©, (hx‚ÇÅ : x ‚àà u)‚ü©,
  classical.by_contradiction $ assume hx‚ÇÇ : x ‚àâ s,
    have u \ s ‚äÜ t,
      from assume x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, or.resolve_left (hu‚ÇÇ h‚ÇÅ) h‚ÇÇ,
    have u \ s ‚äÜ interior t,
      by rwa subset_interior_iff_subset_of_open (is_open_diff hu‚ÇÅ h‚ÇÅ),
    have u \ s ‚äÜ ‚àÖ,
      by rwa h‚ÇÇ at this,
    this ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©,
subset.antisymm
  (interior_maximal this is_open_interior)
  (interior_mono $ subset_union_left _ _)

lemma is_open_iff_forall_mem_open : is_open s ‚Üî ‚àÄ x ‚àà s, ‚àÉ t ‚äÜ s, is_open t ‚àß x ‚àà t :=
by rw ‚Üê subset_interior_iff_open; simp only [subset_def, mem_interior]

/-!
###¬†Closure of a set
-/

/-- The closure of `s` is the smallest closed set containing `s`. -/
def closure (s : set Œ±) : set Œ± := ‚ãÇ‚ÇÄ {t | is_closed t ‚àß s ‚äÜ t}

@[simp] lemma is_closed_closure {s : set Œ±} : is_closed (closure s) :=
is_closed_sInter $ assume t ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h‚ÇÅ

lemma subset_closure {s : set Œ±} : s ‚äÜ closure s :=
subset_sInter $ assume t ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h‚ÇÇ

lemma closure_minimal {s t : set Œ±} (h‚ÇÅ : s ‚äÜ t) (h‚ÇÇ : is_closed t) : closure s ‚äÜ t :=
sInter_subset_of_mem ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©

lemma closure_eq_of_is_closed {s : set Œ±} (h : is_closed s) : closure s = s :=
subset.antisymm (closure_minimal (subset.refl s) h) subset_closure

lemma closure_eq_iff_is_closed {s : set Œ±} : closure s = s ‚Üî is_closed s :=
‚ü®assume h, h ‚ñ∏ is_closed_closure, closure_eq_of_is_closed‚ü©

lemma closure_subset_iff_subset_of_is_closed {s t : set Œ±} (h‚ÇÅ : is_closed t) :
  closure s ‚äÜ t ‚Üî s ‚äÜ t :=
‚ü®subset.trans subset_closure, assume h, closure_minimal h h‚ÇÅ‚ü©

lemma closure_mono {s t : set Œ±} (h : s ‚äÜ t) : closure s ‚äÜ closure t :=
closure_minimal (subset.trans h subset_closure) is_closed_closure

lemma monotone_closure (Œ± : Type*) [topological_space Œ±] : monotone (@closure Œ± _) :=
Œª _ _, closure_mono

lemma closure_inter_subset_inter_closure (s t : set Œ±) :
  closure (s ‚à© t) ‚äÜ closure s ‚à© closure t :=
(monotone_closure Œ±).map_inf_le s t

lemma is_closed_of_closure_subset {s : set Œ±} (h : closure s ‚äÜ s) : is_closed s :=
by rw subset.antisymm subset_closure h; exact is_closed_closure

@[simp] lemma closure_empty : closure (‚àÖ : set Œ±) = ‚àÖ :=
closure_eq_of_is_closed is_closed_empty

lemma closure_empty_iff (s : set Œ±) : closure s = ‚àÖ ‚Üî s = ‚àÖ :=
‚ü®subset_eq_empty subset_closure, Œª h, h.symm ‚ñ∏ closure_empty‚ü©

lemma set.nonempty.closure {s : set Œ±} (h : s.nonempty) :
  set.nonempty (closure s) :=
let ‚ü®x, hx‚ü© := h in ‚ü®x, subset_closure hx‚ü©

@[simp] lemma closure_univ : closure (univ : set Œ±) = univ :=
closure_eq_of_is_closed is_closed_univ

@[simp] lemma closure_closure {s : set Œ±} : closure (closure s) = closure s :=
closure_eq_of_is_closed is_closed_closure

@[simp] lemma closure_union {s t : set Œ±} : closure (s ‚à™ t) = closure s ‚à™ closure t :=
subset.antisymm
  (closure_minimal (union_subset_union subset_closure subset_closure) $ is_closed_union is_closed_closure is_closed_closure)
  ((monotone_closure Œ±).le_map_sup s t)

lemma interior_subset_closure {s : set Œ±} : interior s ‚äÜ closure s :=
subset.trans interior_subset subset_closure

lemma closure_eq_compl_interior_compl {s : set Œ±} : closure s = - interior (- s) :=
begin
  unfold interior closure is_closed,
  rw [compl_sUnion, compl_image_set_of],
  simp only [compl_subset_compl]
end

@[simp] lemma interior_compl {s : set Œ±} : interior (- s) = - closure s :=
by simp [closure_eq_compl_interior_compl]

@[simp] lemma closure_compl {s : set Œ±} : closure (- s) = - interior s :=
by simp [closure_eq_compl_interior_compl]

theorem mem_closure_iff {s : set Œ±} {a : Œ±} :
  a ‚àà closure s ‚Üî ‚àÄ o, is_open o ‚Üí a ‚àà o ‚Üí (o ‚à© s).nonempty :=
‚ü®Œª h o oo ao, classical.by_contradiction $ Œª os,
  have s ‚äÜ -o, from Œª x xs xo, os ‚ü®x, xo, xs‚ü©,
  closure_minimal this (is_closed_compl_iff.2 oo) h ao,
Œª H c ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, classical.by_contradiction $ Œª nc,
  let ‚ü®x, hc, hs‚ü© := (H _ h‚ÇÅ nc) in hc (h‚ÇÇ hs)‚ü©

lemma dense_iff_inter_open {s : set Œ±} :
  closure s = univ ‚Üî ‚àÄ U, is_open U ‚Üí U.nonempty ‚Üí (U ‚à© s).nonempty :=
begin
  split ; intro h,
  { rintros U U_op ‚ü®x, x_in‚ü©,
    exact mem_closure_iff.1 (by simp only [h]) U U_op x_in },
  { apply eq_univ_of_forall, intro x,
    rw mem_closure_iff,
    intros U U_op x_in,
    exact h U U_op ‚ü®_, x_in‚ü© },
end

lemma dense_of_subset_dense {s‚ÇÅ s‚ÇÇ : set Œ±} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) (hd : closure s‚ÇÅ = univ) :
  closure s‚ÇÇ = univ :=
by { rw [‚Üê univ_subset_iff, ‚Üê hd], exact closure_mono h }

/-!
### Frontier of a set
-/

/-- The frontier of a set is the set of points between the closure and interior. -/
def frontier (s : set Œ±) : set Œ± := closure s \ interior s

lemma frontier_eq_closure_inter_closure {s : set Œ±} :
  frontier s = closure s ‚à© closure (- s) :=
by rw [closure_compl, frontier, diff_eq]

/-- The complement of a set has the same frontier as the original set. -/
@[simp] lemma frontier_compl (s : set Œ±) : frontier (-s) = frontier s :=
by simp only [frontier_eq_closure_inter_closure, compl_compl, inter_comm]

lemma frontier_inter_subset (s t : set Œ±) :
  frontier (s ‚à© t) ‚äÜ (frontier s ‚à© closure t) ‚à™ (closure s ‚à© frontier t) :=
begin
  simp only [frontier_eq_closure_inter_closure, compl_inter, closure_union],
  convert inter_subset_inter_left _ (closure_inter_subset_inter_closure s t),
  simp only [inter_distrib_left, inter_distrib_right, inter_assoc],
  congr' 2,
  apply inter_comm
end

lemma frontier_union_subset (s t : set Œ±) :
  frontier (s ‚à™ t) ‚äÜ (frontier s ‚à© closure (-t)) ‚à™ (closure (-s) ‚à© frontier t) :=
by simpa only [frontier_compl, (compl_union _ _).symm]
  using frontier_inter_subset (-s) (-t)

lemma is_closed.frontier_eq {s : set Œ±} (hs : is_closed s) : frontier s = s \ interior s :=
by rw [frontier, closure_eq_of_is_closed hs]

lemma is_open.frontier_eq {s : set Œ±} (hs : is_open s) : frontier s = closure s \ s :=
by rw [frontier, interior_eq_of_open hs]

/-- The frontier of a set is closed. -/
lemma is_closed_frontier {s : set Œ±} : is_closed (frontier s) :=
by rw frontier_eq_closure_inter_closure; exact is_closed_inter is_closed_closure is_closed_closure

/-- The frontier of a closed set has no interior point. -/
lemma interior_frontier {s : set Œ±} (h : is_closed s) : interior (frontier s) = ‚àÖ :=
begin
  have A : frontier s = s \ interior s, from h.frontier_eq,
  have B : interior (frontier s) ‚äÜ interior s, by rw A; exact interior_mono (diff_subset _ _),
  have C : interior (frontier s) ‚äÜ frontier s := interior_subset,
  have : interior (frontier s) ‚äÜ (interior s) ‚à© (s \ interior s) :=
    subset_inter B (by simpa [A] using C),
  rwa [inter_diff_self, subset_empty_iff] at this,
end

/-!
###¬†Neighborhoods
-/

/-- neighbourhood filter -/
def nhds (a : Œ±) : filter Œ± := (‚®Ö s ‚àà {s : set Œ± | a ‚àà s ‚àß is_open s}, ùìü s)

localized "notation `ùìù` := nhds" in topological_space

lemma nhds_def (a : Œ±) : ùìù a = (‚®Ö s ‚àà {s : set Œ± | a ‚àà s ‚àß is_open s}, ùìü s) := rfl

lemma nhds_basis_opens (a : Œ±) : (ùìù a).has_basis (Œª s : set Œ±, a ‚àà s ‚àß is_open s) (Œª x, x) :=
has_basis_binfi_principal
  (Œª s ‚ü®has, hs‚ü© t ‚ü®hat, ht‚ü©, ‚ü®s ‚à© t, ‚ü®‚ü®has, hat‚ü©, is_open_inter hs ht‚ü©,
    ‚ü®inter_subset_left _ _, inter_subset_right _ _‚ü©‚ü©)
  ‚ü®univ, ‚ü®mem_univ a, is_open_univ‚ü©‚ü©

lemma le_nhds_iff {f a} : f ‚â§ ùìù a ‚Üî ‚àÄ s : set Œ±, a ‚àà s ‚Üí is_open s ‚Üí s ‚àà f :=
by simp [nhds_def]

lemma nhds_le_of_le {f a} {s : set Œ±} (h : a ‚àà s) (o : is_open s) (sf : ùìü s ‚â§ f) : ùìù a ‚â§ f :=
by rw nhds_def; exact infi_le_of_le s (infi_le_of_le ‚ü®h, o‚ü© sf)

lemma mem_nhds_sets_iff {a : Œ±} {s : set Œ±} :
 s ‚àà ùìù a ‚Üî ‚àÉt‚äÜs, is_open t ‚àß a ‚àà t :=
(nhds_basis_opens a).mem_iff.trans
  ‚ü®Œª ‚ü®t, ‚ü®hat, ht‚ü©, hts‚ü©, ‚ü®t, hts, ht, hat‚ü©, Œª ‚ü®t, hts, ht, hat‚ü©, ‚ü®t, ‚ü®hat, ht‚ü©, hts‚ü©‚ü©

lemma map_nhds {a : Œ±} {f : Œ± ‚Üí Œ≤} :
  map f (ùìù a) = (‚®Ö s ‚àà {s : set Œ± | a ‚àà s ‚àß is_open s}, ùìü (image f s)) :=
((nhds_basis_opens a).map f).eq_binfi

attribute [irreducible] nhds

lemma mem_of_nhds {a : Œ±} {s : set Œ±} : s ‚àà ùìù a ‚Üí a ‚àà s :=
Œª H, let ‚ü®t, ht, _, hs‚ü© := mem_nhds_sets_iff.1 H in ht hs

lemma filter.eventually.self_of_nhds {p : Œ± ‚Üí Prop} {a : Œ±}
  (h : ‚àÄ·∂† y in ùìù a, p y) : p a :=
mem_of_nhds h

lemma mem_nhds_sets {a : Œ±} {s : set Œ±} (hs : is_open s) (ha : a ‚àà s) :
 s ‚àà ùìù a :=
mem_nhds_sets_iff.2 ‚ü®s, subset.refl _, hs, ha‚ü©

theorem all_mem_nhds (x : Œ±) (P : set Œ± ‚Üí Prop) (hP : ‚àÄ s t, s ‚äÜ t ‚Üí P s ‚Üí P t) :
  (‚àÄ s ‚àà ùìù x, P s) ‚Üî (‚àÄ s, is_open s ‚Üí x ‚àà s ‚Üí P s) :=
iff.intro
  (Œª h s os xs, h s (mem_nhds_sets os xs))
  (Œª h t,
    begin
      change t ‚àà ùìù x ‚Üí P t,
      rw mem_nhds_sets_iff,
      rintros ‚ü®s, hs, opens, xs‚ü©,
      exact hP _ _ hs (h s opens xs),
    end)

theorem all_mem_nhds_filter (x : Œ±) (f : set Œ± ‚Üí set Œ≤) (hf : ‚àÄ s t, s ‚äÜ t ‚Üí f s ‚äÜ f t)
    (l : filter Œ≤) :
  (‚àÄ s ‚àà ùìù x, f s ‚àà l) ‚Üî (‚àÄ s, is_open s ‚Üí x ‚àà s ‚Üí f s ‚àà l) :=
all_mem_nhds _ _ (Œª s t ssubt h, mem_sets_of_superset h (hf s t ssubt))

theorem rtendsto_nhds {r : rel Œ≤ Œ±} {l : filter Œ≤} {a : Œ±} :
  rtendsto r l (ùìù a) ‚Üî (‚àÄ s, is_open s ‚Üí a ‚àà s ‚Üí r.core s ‚àà l) :=
all_mem_nhds_filter _ _ (Œª s t, id) _

theorem rtendsto'_nhds {r : rel Œ≤ Œ±} {l : filter Œ≤} {a : Œ±} :
  rtendsto' r l (ùìù a) ‚Üî (‚àÄ s, is_open s ‚Üí a ‚àà s ‚Üí r.preimage s ‚àà l) :=
by { rw [rtendsto'_def], apply all_mem_nhds_filter, apply rel.preimage_mono }

theorem ptendsto_nhds {f : Œ≤ ‚Üí. Œ±} {l : filter Œ≤} {a : Œ±} :
  ptendsto f l (ùìù a) ‚Üî (‚àÄ s, is_open s ‚Üí a ‚àà s ‚Üí f.core s ‚àà l) :=
rtendsto_nhds

theorem ptendsto'_nhds {f : Œ≤ ‚Üí. Œ±} {l : filter Œ≤} {a : Œ±} :
  ptendsto' f l (ùìù a) ‚Üî (‚àÄ s, is_open s ‚Üí a ‚àà s ‚Üí f.preimage s ‚àà l) :=
rtendsto'_nhds

theorem tendsto_nhds {f : Œ≤ ‚Üí Œ±} {l : filter Œ≤} {a : Œ±} :
  tendsto f l (ùìù a) ‚Üî (‚àÄ s, is_open s ‚Üí a ‚àà s ‚Üí f ‚Åª¬π' s ‚àà l) :=
all_mem_nhds_filter _ _ (Œª s t h, preimage_mono h) _

lemma tendsto_const_nhds {a : Œ±} {f : filter Œ≤} : tendsto (Œªb:Œ≤, a) f (ùìù a) :=
tendsto_nhds.mpr $ assume s hs ha, univ_mem_sets' $ assume _, ha

lemma pure_le_nhds : pure ‚â§ (ùìù : Œ± ‚Üí filter Œ±) :=
assume a s hs, mem_pure_sets.2 $ mem_of_nhds hs

lemma tendsto_pure_nhds {Œ± : Type*} [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (a : Œ±) :
  tendsto f (pure a) (ùìù (f a)) :=
begin
  rw [tendsto, filter.map_pure],
  exact pure_le_nhds (f a)
end

@[simp] lemma nhds_ne_bot {a : Œ±} : ùìù a ‚â† ‚ä• :=
ne_bot_of_le_ne_bot pure_ne_bot (pure_le_nhds a)

/-!
###¬†Cluster points

In this section we define [cluster points](https://en.wikipedia.org/wiki/Limit_point)
(also known as limit points and accumulation points) of a filter and of a sequence.
-/

/-- A point `x` is a cluster point of a filter `F` if ùìù x ‚äì F ‚â† ‚ä•. Also known as
an accumulation point or a limit point. -/
def cluster_pt (x : Œ±) (F : filter Œ±) : Prop := ùìù x ‚äì F ‚â† ‚ä•

lemma cluster_pt.of_le_nhds {x : Œ±} {f : filter Œ±} (H : f ‚â§ ùìù x) (h : f ‚â† ‚ä•) : cluster_pt x f :=
by rwa [cluster_pt, inf_comm, inf_eq_left.mpr H]

lemma cluster_pt.of_nhds_le {x : Œ±} {f : filter Œ±} (H : ùìù x ‚â§ f) : cluster_pt x f :=
by simp [cluster_pt, inf_eq_left.mpr H]

lemma cluster_pt.mono {x : Œ±} {f g : filter Œ±} (H : cluster_pt x f) (h : f ‚â§ g) :
  cluster_pt x g :=
ne_bot_of_le_ne_bot H $ inf_le_inf_left _ h

lemma cluster_pt_of_inf_left {x : Œ±} {f g : filter Œ±} (H : cluster_pt x $ f ‚äì g) :
  cluster_pt x f :=
H.mono inf_le_left

lemma cluster_pt_of_inf_right {x : Œ±} {f g : filter Œ±} (H : cluster_pt x $ f ‚äì g) :
  cluster_pt x g :=
H.mono inf_le_right

/-- A point `x` is a cluster point of a sequence `u` along a filter `F` if it is a cluster point
of `map u F`. -/
def map_cluster_pt {Œπ :Type*} (x : Œ±) (F : filter Œπ) (u : Œπ ‚Üí Œ±) : Prop := cluster_pt x (map u F)

lemma map_cluster_pt_iff {Œπ :Type*} (x : Œ±) (F : filter Œπ) (u : Œπ ‚Üí Œ±) :
  map_cluster_pt x F u ‚Üî ‚àÄ s ‚àà ùìù x, ‚àÉ·∂† a in F, u a ‚àà s :=
by { simp_rw [map_cluster_pt, cluster_pt, inf_ne_bot_iff_frequently_left, frequently_map], refl }

lemma map_cluster_pt_of_comp {Œπ Œ¥ :Type*} {F : filter Œπ} {œÜ : Œ¥ ‚Üí Œπ} {p : filter Œ¥}
  {x : Œ±} {u : Œπ ‚Üí Œ±} (hp : p ‚â† ‚ä•) (h : tendsto œÜ p F) (H : tendsto (u ‚àò œÜ) p (ùìù x)) :
  map_cluster_pt x F u :=
begin
  have := calc
  map (u ‚àò œÜ) p = map u (map œÜ p) : map_map
  ... ‚â§ map u F : map_mono h,
  have : map (u ‚àò œÜ) p ‚â§ ùìù x ‚äì map u F,
    from le_inf H this,
  exact ne_bot_of_le_ne_bot (map_ne_bot hp) this
end

/-!
###¬†Interior, closure and frontier in terms of neighborhoods
-/

lemma interior_eq_nhds {s : set Œ±} : interior s = {a | ùìù a ‚â§ ùìü s} :=
set.ext $ Œª x, by simp only [mem_interior, le_principal_iff, mem_nhds_sets_iff]; refl

lemma mem_interior_iff_mem_nhds {s : set Œ±} {a : Œ±} :
  a ‚àà interior s ‚Üî s ‚àà ùìù a :=
by simp only [interior_eq_nhds, le_principal_iff]; refl

lemma is_open_iff_nhds {s : set Œ±} : is_open s ‚Üî ‚àÄa‚ààs, ùìù a ‚â§ ùìü s :=
calc is_open s ‚Üî s ‚äÜ interior s : subset_interior_iff_open.symm
  ... ‚Üî (‚àÄa‚ààs, ùìù a ‚â§ ùìü s) : by rw [interior_eq_nhds]; refl

lemma is_open_iff_mem_nhds {s : set Œ±} : is_open s ‚Üî ‚àÄa‚ààs, s ‚àà ùìù a :=
is_open_iff_nhds.trans $ forall_congr $ Œª _, imp_congr_right $ Œª _, le_principal_iff

lemma closure_eq_cluster_pts {s : set Œ±} : closure s = {a | cluster_pt a (ùìü s)} :=
calc closure s = - interior (- s) : closure_eq_compl_interior_compl
  ... = {a | ¬¨ ùìù a ‚â§ ùìü (-s)} : by rw [interior_eq_nhds]; refl
  ... = {a | cluster_pt a (ùìü s)} : set.ext $ assume a, not_congr
    (inf_eq_bot_iff_le_compl
      (show ùìü s ‚äî ùìü (-s) = ‚ä§, by simp only [sup_principal, union_compl_self, principal_univ])
      (by simp only [inf_principal, inter_compl_self, principal_empty])).symm

theorem mem_closure_iff_nhds {s : set Œ±} {a : Œ±} :
  a ‚àà closure s ‚Üî ‚àÄ t ‚àà ùìù a, (t ‚à© s).nonempty :=
mem_closure_iff.trans
‚ü®Œª H t ht, nonempty.mono
  (inter_subset_inter_left _ interior_subset)
  (H _ is_open_interior (mem_interior_iff_mem_nhds.2 ht)),
 Œª H o oo ao, H _ (mem_nhds_sets oo ao)‚ü©

theorem mem_closure_iff_nhds_basis {a : Œ±} {p : Œ≤ ‚Üí Prop} {s : Œ≤ ‚Üí set Œ±} (h : (ùìù a).has_basis p s)
  {t : set Œ±} :
  a ‚àà closure t ‚Üî ‚àÄ i, p i ‚Üí ‚àÉ y ‚àà t, y ‚àà s i :=
mem_closure_iff_nhds.trans
  ‚ü®Œª H i hi, let ‚ü®x, hx‚ü© := (H _ $ h.mem_of_mem hi) in ‚ü®x, hx.2, hx.1‚ü©,
    Œª H t' ht', let ‚ü®i, hi, hit‚ü© := h.mem_iff.1 ht', ‚ü®x, xt, hx‚ü© := H i hi in
    ‚ü®x, hit hx, xt‚ü©‚ü©

/-- `x` belongs to the closure of `s` if and only if some ultrafilter
  supported on `s` converges to `x`. -/
lemma mem_closure_iff_ultrafilter {s : set Œ±} {x : Œ±} :
  x ‚àà closure s ‚Üî ‚àÉ (u : ultrafilter Œ±), s ‚àà u.val ‚àß u.val ‚â§ ùìù x :=
begin
  rw closure_eq_cluster_pts, change cluster_pt x (ùìü s) ‚Üî _, symmetry,
  convert exists_ultrafilter_iff _, ext u,
  rw [‚Üêle_principal_iff, inf_comm, le_inf_iff]
end

lemma is_closed_iff_nhds {s : set Œ±} : is_closed s ‚Üî ‚àÄa, cluster_pt a (ùìü s) ‚Üí a ‚àà s :=
calc is_closed s ‚Üî closure s = s : by rw [closure_eq_iff_is_closed]
  ... ‚Üî closure s ‚äÜ s : ‚ü®assume h, by rw h, assume h, subset.antisymm h subset_closure‚ü©
  ... ‚Üî (‚àÄa, cluster_pt a (ùìü s) ‚Üí a ‚àà s) : by rw [closure_eq_cluster_pts]; refl

lemma closure_inter_open {s t : set Œ±} (h : is_open s) : s ‚à© closure t ‚äÜ closure (s ‚à© t) :=
assume a ‚ü®hs, ht‚ü©,
have s ‚àà ùìù a, from mem_nhds_sets h hs,
have ùìù a ‚äì ùìü s = ùìù a, by rwa [inf_eq_left, le_principal_iff],
have cluster_pt a (ùìü (s ‚à© t)),
  from calc ùìù a ‚äì ùìü (s ‚à© t) = ùìù a ‚äì (ùìü s ‚äì ùìü t) : by rw inf_principal
    ... = ùìù a ‚äì ùìü t : by rw [‚Üêinf_assoc, this]
    ... ‚â† ‚ä• : by rw [closure_eq_cluster_pts] at ht; assumption,
by rwa [closure_eq_cluster_pts]

lemma dense_inter_of_open_left {s t : set Œ±} (hs : closure s = univ) (ht : closure t = univ)
  (hso : is_open s) :
  closure (s ‚à© t) = univ :=
eq_univ_of_subset (closure_minimal (closure_inter_open hso) is_closed_closure) $
  by simp only [*, inter_univ]

lemma dense_inter_of_open_right {s t : set Œ±} (hs : closure s = univ) (ht : closure t = univ)
  (hto : is_open t) :
  closure (s ‚à© t) = univ :=
inter_comm t s ‚ñ∏ dense_inter_of_open_left ht hs hto

lemma closure_diff {s t : set Œ±} : closure s - closure t ‚äÜ closure (s - t) :=
calc closure s \ closure t = (- closure t) ‚à© closure s : by simp only [diff_eq, inter_comm]
  ... ‚äÜ closure (- closure t ‚à© s) : closure_inter_open $ is_open_compl_iff.mpr $ is_closed_closure
  ... = closure (s \ closure t) : by simp only [diff_eq, inter_comm]
  ... ‚äÜ closure (s \ t) : closure_mono $ diff_subset_diff (subset.refl s) subset_closure

lemma mem_of_closed_of_tendsto {f : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±} {s : set Œ±}
  (hb : b ‚â† ‚ä•) (hf : tendsto f b (ùìù a)) (hs : is_closed s) (h : f ‚Åª¬π' s ‚àà b) : a ‚àà s :=
have b.map f ‚â§ ùìù a ‚äì ùìü s,
  from le_trans (le_inf (le_refl _) (le_principal_iff.mpr h)) (inf_le_inf_right _ hf),
is_closed_iff_nhds.mp hs a $ ne_bot_of_le_ne_bot (map_ne_bot hb) this

lemma mem_of_closed_of_tendsto' {f : Œ≤ ‚Üí Œ±} {x : filter Œ≤} {a : Œ±} {s : set Œ±}
  (hf : tendsto f x (ùìù a)) (hs : is_closed s) (h : x ‚äì ùìü (f ‚Åª¬π' s) ‚â† ‚ä•) : a ‚àà s :=
is_closed_iff_nhds.mp hs _ $ ne_bot_of_le_ne_bot (@map_ne_bot _ _ _ f h) $
  le_inf (le_trans (map_mono $ inf_le_left) hf) $
    le_trans (map_mono $ inf_le_right_of_le $
      by simp only [comap_principal, le_principal_iff]; exact subset.refl _) (@map_comap_le _ _ _ f)

lemma mem_closure_of_tendsto {f : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±} {s : set Œ±}
  (hb : b ‚â† ‚ä•) (hf : tendsto f b (ùìù a)) (h : ‚àÄ·∂† x in b, f x ‚àà s) : a ‚àà closure s :=
mem_of_closed_of_tendsto hb hf (is_closed_closure) $
  filter.mem_sets_of_superset h (preimage_mono subset_closure)

/-- Suppose that `f` sends the complement to `s` to a single point `a`, and `l` is some filter.
Then `f` tends to `a` along `l` restricted to `s` if and only it tends to `a` along `l`. -/
lemma tendsto_inf_principal_nhds_iff_of_forall_eq {f : Œ≤ ‚Üí Œ±} {l : filter Œ≤} {s : set Œ≤}
  {a : Œ±} (h : ‚àÄ x ‚àâ s, f x = a) :
  tendsto f (l ‚äì ùìü s) (ùìù a) ‚Üî tendsto f l (ùìù a) :=
begin
  rw [tendsto_iff_comap, tendsto_iff_comap],
  replace h : ùìü (-s) ‚â§ comap f (ùìù a),
  { rintros U ‚ü®t, ht, htU‚ü© x hx,
    have : f x ‚àà t, from (h x hx).symm ‚ñ∏ mem_of_nhds ht,
    exact htU this },
  refine ‚ü®Œª h', _, le_trans inf_le_left‚ü©,
  have := sup_le h' h,
  rw [sup_inf_right, sup_principal, union_compl_self, principal_univ,
    inf_top_eq, sup_le_iff] at this,
  exact this.1
end

/-!
### Limits of filters in topological spaces
-/

section lim

/-- If `f` is a filter, then `Lim f` is a limit of the filter, if it exists. -/
noncomputable def Lim [nonempty Œ±] (f : filter Œ±) : Œ± := epsilon $ Œªa, f ‚â§ ùìù a

/-- If `f` is a filter in `Œ≤` and `g : Œ≤ ‚Üí Œ±` is a function, then `lim f` is a limit of `g` at `f`,
if it exists. -/
noncomputable def lim [nonempty Œ±] (f : filter Œ≤) (g : Œ≤ ‚Üí Œ±) : Œ± :=
Lim (f.map g)

/-- If a filter `f` is majorated by some `ùìù a`, then it is majorated by `ùìù (Lim f)`. We formulate
this lemma with a `[nonempty Œ±]` argument of `Lim` derived from `h` to make it useful for types
without a `[nonempty Œ±]` instance. Because of the built-in proof irrelevance, Lean will unify
this instance with any other instance. -/
lemma Lim_spec {f : filter Œ±} (h : ‚àÉa, f ‚â§ ùìù a) : f ‚â§ ùìù (@Lim _ _ (nonempty_of_exists h) f) :=
epsilon_spec h

/-- If `g` tends to some `ùìù a` along `f`, then it tends to `ùìù (lim f g)`. We formulate
this lemma with a `[nonempty Œ±]` argument of `lim` derived from `h` to make it useful for types
without a `[nonempty Œ±]` instance. Because of the built-in proof irrelevance, Lean will unify
this instance with any other instance. -/
lemma lim_spec {f : filter Œ≤} {g : Œ≤ ‚Üí Œ±} (h : ‚àÉ a, tendsto g f (ùìù a)) :
  tendsto g f (ùìù $ @lim _ _ _ (nonempty_of_exists h) f g) :=
Lim_spec h

end lim

/-!
###¬†Locally finite families
-/

/- locally finite family [General Topology (Bourbaki, 1995)] -/
section locally_finite

/-- A family of sets in `set Œ±` is locally finite if at every point `x:Œ±`,
  there is a neighborhood of `x` which meets only finitely many sets in the family -/
def locally_finite (f : Œ≤ ‚Üí set Œ±) :=
‚àÄx:Œ±, ‚àÉt ‚àà ùìù x, finite {i | (f i ‚à© t).nonempty }

lemma locally_finite_of_finite {f : Œ≤ ‚Üí set Œ±} (h : finite (univ : set Œ≤)) : locally_finite f :=
assume x, ‚ü®univ, univ_mem_sets, h.subset $ subset_univ _‚ü©

lemma locally_finite_subset
  {f‚ÇÅ f‚ÇÇ : Œ≤ ‚Üí set Œ±} (hf‚ÇÇ : locally_finite f‚ÇÇ) (hf : ‚àÄb, f‚ÇÅ b ‚äÜ f‚ÇÇ b) : locally_finite f‚ÇÅ :=
assume a,
let ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := hf‚ÇÇ a in
‚ü®t, ht‚ÇÅ, ht‚ÇÇ.subset $ assume i hi, hi.mono $ inter_subset_inter (hf i) $ subset.refl _‚ü©

lemma is_closed_Union_of_locally_finite {f : Œ≤ ‚Üí set Œ±}
  (h‚ÇÅ : locally_finite f) (h‚ÇÇ : ‚àÄi, is_closed (f i)) : is_closed (‚ãÉi, f i) :=
is_open_iff_nhds.mpr $ assume a, assume h : a ‚àâ (‚ãÉi, f i),
  have ‚àÄi, a ‚àà -f i,
    from assume i hi, h $ mem_Union.2 ‚ü®i, hi‚ü©,
  have ‚àÄi, - f i ‚àà (ùìù a),
    by simp only [mem_nhds_sets_iff]; exact assume i, ‚ü®- f i, subset.refl _, h‚ÇÇ i, this i‚ü©,
  let ‚ü®t, h_sets, (h_fin : finite {i | (f i ‚à© t).nonempty })‚ü© := h‚ÇÅ a in

  calc ùìù a ‚â§ ùìü (t ‚à© (‚ãÇ i‚àà{i | (f i ‚à© t).nonempty }, - f i)) :
  begin
    rw [le_principal_iff],
    apply @filter.inter_mem_sets _ (ùìù a) _ _ h_sets,
    apply @filter.Inter_mem_sets _ (ùìù a) _ _ _ h_fin,
    exact assume i h, this i
  end
  ... ‚â§ ùìü (- ‚ãÉi, f i) :
  begin
    simp only [principal_mono, subset_def, mem_compl_eq, mem_inter_eq,
      mem_Inter, mem_set_of_eq, mem_Union, and_imp, not_exists,
      exists_imp_distrib, ne_empty_iff_nonempty, set.nonempty],
    exact assume x xt ht i xfi, ht i x xfi xt xfi
  end

end locally_finite

end topological_space

/-!
### Continuity
-/

section continuous
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {Œ¥ : Type*}
variables [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥]
open_locale topological_space

/-- A function between topological spaces is continuous if the preimage
  of every open set is open. -/
def continuous (f : Œ± ‚Üí Œ≤) := ‚àÄs, is_open s ‚Üí is_open (f ‚Åª¬π' s)

/-- A function between topological spaces is continuous at a point `x‚ÇÄ`
if `f x` tends to `f x‚ÇÄ` when `x` tends to `x‚ÇÄ`. -/
def continuous_at (f : Œ± ‚Üí Œ≤) (x : Œ±) := tendsto f (ùìù x) (ùìù (f x))

lemma continuous_at.tendsto {f : Œ± ‚Üí Œ≤} {x : Œ±} (h : continuous_at f x) :
  tendsto f (ùìù x) (ùìù (f x)) :=
h

lemma continuous_at.preimage_mem_nhds {f : Œ± ‚Üí Œ≤} {x : Œ±} {t : set Œ≤} (h : continuous_at f x)
  (ht : t ‚àà ùìù (f x)) : f ‚Åª¬π' t ‚àà ùìù x :=
h ht

lemma preimage_interior_subset_interior_preimage {f : Œ± ‚Üí Œ≤} {s : set Œ≤}
  (hf : continuous f) : f‚Åª¬π' (interior s) ‚äÜ interior (f‚Åª¬π' s) :=
interior_maximal (preimage_mono interior_subset) (hf _ is_open_interior)

lemma continuous_id : continuous (id : Œ± ‚Üí Œ±) :=
assume s h, h

lemma continuous.comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : continuous g) (hf : continuous f) :
  continuous (g ‚àò f) :=
assume s h, hf _ (hg s h)

lemma continuous.iterate {f : Œ± ‚Üí Œ±} (h : continuous f) (n : ‚Ñï) : continuous (f^[n]) :=
nat.rec_on n continuous_id (Œª n ihn, ihn.comp h)

lemma continuous_at.comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {x : Œ±}
  (hg : continuous_at g (f x)) (hf : continuous_at f x) :
  continuous_at (g ‚àò f) x :=
hg.comp hf

lemma continuous.tendsto {f : Œ± ‚Üí Œ≤} (hf : continuous f) (x) :
  tendsto f (ùìù x) (ùìù (f x)) :=
((nhds_basis_opens x).tendsto_iff $ nhds_basis_opens $ f x).2 $
  Œª t ‚ü®hxt, ht‚ü©, ‚ü®f ‚Åª¬π' t, ‚ü®hxt, hf _ ht‚ü©, subset.refl _‚ü©

lemma continuous.continuous_at {f : Œ± ‚Üí Œ≤} {x : Œ±} (h : continuous f) :
  continuous_at f x :=
h.tendsto x

lemma continuous_iff_continuous_at {f : Œ± ‚Üí Œ≤} : continuous f ‚Üî ‚àÄ x, continuous_at f x :=
‚ü®continuous.tendsto,
  assume hf : ‚àÄx, tendsto f (ùìù x) (ùìù (f x)),
  assume s, assume hs : is_open s,
  have ‚àÄa, f a ‚àà s ‚Üí s ‚àà ùìù (f a),
    from Œª a ha, mem_nhds_sets hs ha,
  show is_open (f ‚Åª¬π' s),
    from is_open_iff_nhds.2 $ Œª a ha, le_principal_iff.2 $ hf _ (this a ha)‚ü©

lemma continuous_const {b : Œ≤} : continuous (Œªa:Œ±, b) :=
continuous_iff_continuous_at.mpr $ assume a, tendsto_const_nhds

lemma continuous_at_const {x : Œ±} {b : Œ≤} : continuous_at (Œª a:Œ±, b) x :=
continuous_const.continuous_at

lemma continuous_at_id {x : Œ±} : continuous_at id x :=
continuous_id.continuous_at

lemma continuous_at.iterate {f : Œ± ‚Üí Œ±} {x : Œ±} (hf : continuous_at f x) (hx : f x = x) (n : ‚Ñï) :
  continuous_at (f^[n]) x :=
nat.rec_on n continuous_at_id $ Œª n ihn,
show continuous_at (f^[n] ‚àò f) x,
from continuous_at.comp (hx.symm ‚ñ∏ ihn) hf

lemma continuous_iff_is_closed {f : Œ± ‚Üí Œ≤} :
  continuous f ‚Üî (‚àÄs, is_closed s ‚Üí is_closed (f ‚Åª¬π' s)) :=
‚ü®assume hf s hs, hf (-s) hs,
  assume hf s, by rw [‚Üêis_closed_compl_iff, ‚Üêis_closed_compl_iff]; exact hf _‚ü©

lemma continuous_at_iff_ultrafilter {f : Œ± ‚Üí Œ≤} (x) : continuous_at f x ‚Üî
  ‚àÄ g, is_ultrafilter g ‚Üí g ‚â§ ùìù x ‚Üí g.map f ‚â§ ùìù (f x) :=
tendsto_iff_ultrafilter f (ùìù x) (ùìù (f x))

lemma continuous_iff_ultrafilter {f : Œ± ‚Üí Œ≤} :
  continuous f ‚Üî ‚àÄ x g, is_ultrafilter g ‚Üí g ‚â§ ùìù x ‚Üí g.map f ‚â§ ùìù (f x) :=
by simp only [continuous_iff_continuous_at, continuous_at_iff_ultrafilter]

/-- A piecewise defined function `if p then f else g` is continuous, if both `f` and `g`
are continuous, and they coincide on the frontier (boundary) of the set `{a | p a}`. -/
lemma continuous_if {p : Œ± ‚Üí Prop} {f g : Œ± ‚Üí Œ≤} {h : ‚àÄa, decidable (p a)}
  (hp : ‚àÄa‚ààfrontier {a | p a}, f a = g a) (hf : continuous f) (hg : continuous g) :
  continuous (Œªa, @ite (p a) (h a) Œ≤ (f a) (g a)) :=
continuous_iff_is_closed.mpr $
assume s hs,
have (Œªa, ite (p a) (f a) (g a)) ‚Åª¬π' s =
    (closure {a | p a} ‚à©  f ‚Åª¬π' s) ‚à™ (closure {a | ¬¨ p a} ‚à© g ‚Åª¬π' s),
  from set.ext $ assume a,
  classical.by_cases
    (assume : a ‚àà frontier {a | p a},
      have hac : a ‚àà closure {a | p a}, from this.left,
      have hai : a ‚àà closure {a | ¬¨ p a},
        from have a ‚àà - interior {a | p a}, from this.right, by rwa [‚Üêclosure_compl] at this,
      by by_cases p a; simp [h, hp a this, hac, hai, iff_def] {contextual := tt})
    (assume hf : a ‚àà - frontier {a | p a},
      classical.by_cases
        (assume : p a,
          have hc : a ‚àà closure {a | p a}, from subset_closure this,
          have hnc : a ‚àâ closure {a | ¬¨ p a},
            by show a ‚àâ closure (- {a | p a}); rw [closure_compl]; simpa [frontier, hc] using hf,
          by simp [this, hc, hnc])
        (assume : ¬¨ p a,
          have hc : a ‚àà closure {a | ¬¨ p a}, from subset_closure this,
          have hnc : a ‚àâ closure {a | p a},
            begin
              have hc : a ‚àà closure (- {a | p a}), from hc,
              simp [closure_compl] at hc,
              simpa [frontier, hc] using hf
            end,
          by simp [this, hc, hnc])),
by rw [this]; exact is_closed_union
  (is_closed_inter is_closed_closure $ continuous_iff_is_closed.mp hf s hs)
  (is_closed_inter is_closed_closure $ continuous_iff_is_closed.mp hg s hs)


/- Continuity and partial functions -/

/-- Continuity of a partial function -/
def pcontinuous (f : Œ± ‚Üí. Œ≤) := ‚àÄ s, is_open s ‚Üí is_open (f.preimage s)

lemma open_dom_of_pcontinuous {f : Œ± ‚Üí. Œ≤} (h : pcontinuous f) : is_open f.dom :=
by rw [‚Üêpfun.preimage_univ]; exact h _ is_open_univ

lemma pcontinuous_iff' {f : Œ± ‚Üí. Œ≤} :
  pcontinuous f ‚Üî ‚àÄ {x y} (h : y ‚àà f x), ptendsto' f (ùìù x) (ùìù y) :=
begin
  split,
  { intros h x y h',
    simp only [ptendsto'_def, mem_nhds_sets_iff],
    rintros s ‚ü®t, tsubs, opent, yt‚ü©,
    exact ‚ü®f.preimage t, pfun.preimage_mono _ tsubs, h _ opent, ‚ü®y, yt, h'‚ü©‚ü©
  },
  intros hf s os,
  rw is_open_iff_nhds,
  rintros x ‚ü®y, ys, fxy‚ü© t,
  rw [mem_principal_sets],
  assume h : f.preimage s ‚äÜ t,
  change t ‚àà ùìù x,
  apply mem_sets_of_superset _ h,
  have h' : ‚àÄ s ‚àà ùìù y, f.preimage s ‚àà ùìù x,
  { intros s hs,
     have : ptendsto' f (ùìù x) (ùìù y) := hf fxy,
     rw ptendsto'_def at this,
     exact this s hs },
  show f.preimage s ‚àà ùìù x,
  apply h', rw mem_nhds_sets_iff, exact ‚ü®s, set.subset.refl _, os, ys‚ü©
end

lemma image_closure_subset_closure_image {f : Œ± ‚Üí Œ≤} {s : set Œ±} (h : continuous f) :
  f '' closure s ‚äÜ closure (f '' s) :=
have ‚àÄ (a : Œ±), cluster_pt a (ùìü s) ‚Üí cluster_pt (f a) (ùìü (f '' s)),
  from assume a ha,
  have h‚ÇÅ : ¬¨ map f (ùìù a ‚äì ùìü s) = ‚ä•,
    by rwa[map_eq_bot_iff],
  have h‚ÇÇ : map f (ùìù a ‚äì ùìü s) ‚â§ ùìù (f a) ‚äì ùìü (f '' s),
    from le_inf
      (le_trans (map_mono inf_le_left) $ by rw [continuous_iff_continuous_at] at h; exact h a)
      (le_trans (map_mono inf_le_right) $ by simp; exact subset.refl _),
  ne_bot_of_le_ne_bot h‚ÇÅ h‚ÇÇ,
by simp [image_subset_iff, closure_eq_cluster_pts]; assumption

lemma mem_closure {s : set Œ±} {t : set Œ≤} {f : Œ± ‚Üí Œ≤} {a : Œ±}
  (hf : continuous f) (ha : a ‚àà closure s) (ht : ‚àÄa‚ààs, f a ‚àà t) : f a ‚àà closure t :=
subset.trans (image_closure_subset_closure_image hf) (closure_mono $ image_subset_iff.2 ht) $
  (mem_image_of_mem f ha)

end continuous
