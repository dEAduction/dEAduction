/-
Copyright (c) 2019 Johan Commelin All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin
-/
import order.filter.lift
import topology.opens
import topology.algebra.ring

open topological_space
open_locale topological_space

set_option old_structure_cmd true

/-- The type of open subgroups of a topological additive group. -/
@[ancestor add_subgroup]
structure open_add_subgroup  (G : Type*) [add_group G] [topological_space G]
  extends add_subgroup G :=
(is_open' : is_open carrier)

/-- The type of open subgroups of a topological group. -/
@[ancestor subgroup, to_additive open_add_subgroup]
structure open_subgroup (G : Type*) [group G] [topological_space G] extends subgroup G :=
(is_open' : is_open carrier)

/-- Reinterpret an `open_subgroup` as a `subgroup`. -/
add_decl_doc open_subgroup.to_subgroup

/-- Reinterpret an `open_add_subgroup` as an `add_subgroup`. -/
add_decl_doc open_add_subgroup.to_add_subgroup

-- Tell Lean that `open_add_subgroup` is a namespace
namespace open_add_subgroup
end open_add_subgroup

namespace open_subgroup
open function topological_space
variables {G : Type*} [group G] [topological_space G]
variables {U V : open_subgroup G} {g : G}

@[to_additive]
instance has_coe_set : has_coe_t (open_subgroup G) (set G) := ‚ü®Œª U, U.1‚ü©

@[to_additive]
instance : has_mem G (open_subgroup G) := ‚ü®Œª g U, g ‚àà (U : set G)‚ü©

@[to_additive]
instance has_coe_subgroup : has_coe_t (open_subgroup G) (subgroup G) := ‚ü®to_subgroup‚ü©

@[to_additive]
instance has_coe_opens : has_coe_t (open_subgroup G) (opens G) := ‚ü®Œª U, ‚ü®U, U.is_open'‚ü©‚ü©

@[simp, to_additive] lemma mem_coe : g ‚àà (U : set G) ‚Üî g ‚àà U := iff.rfl
@[simp, to_additive] lemma mem_coe_opens : g ‚àà (U : opens G) ‚Üî g ‚àà U := iff.rfl
@[simp, to_additive mem_coe_add_subgroup]
lemma mem_coe_subgroup : g ‚àà (U : subgroup G) ‚Üî g ‚àà U := iff.rfl

attribute [norm_cast] mem_coe mem_coe_opens mem_coe_subgroup open_add_subgroup.mem_coe
  open_add_subgroup.mem_coe_opens open_add_subgroup.mem_coe_add_subgroup

@[to_additive] lemma coe_injective : injective (coe : open_subgroup G ‚Üí set G) :=
Œª U V h, by cases U; cases V; congr; assumption

@[ext, to_additive]
lemma ext (h : ‚àÄ x, x ‚àà U ‚Üî x ‚àà V) : (U = V) := coe_injective $ set.ext h

@[to_additive]
lemma ext_iff : (U = V) ‚Üî (‚àÄ x, x ‚àà U ‚Üî x ‚àà V) := ‚ü®Œª h x, h ‚ñ∏ iff.rfl, ext‚ü©

variable (U)
@[to_additive]
protected lemma is_open : is_open (U : set G) := U.is_open'

@[to_additive]
protected lemma one_mem : (1 : G) ‚àà U := U.one_mem'

@[to_additive]
protected lemma inv_mem {g : G} (h : g ‚àà U) : g‚Åª¬π ‚àà U := U.inv_mem' h

@[to_additive]
protected lemma mul_mem {g‚ÇÅ g‚ÇÇ : G} (h‚ÇÅ : g‚ÇÅ ‚àà U) (h‚ÇÇ : g‚ÇÇ ‚àà U) : g‚ÇÅ * g‚ÇÇ ‚àà U := U.mul_mem' h‚ÇÅ h‚ÇÇ

@[to_additive]
lemma mem_nhds_one : (U : set G) ‚àà ùìù (1 : G) :=
mem_nhds_sets U.is_open U.one_mem
variable {U}

@[to_additive]
instance : has_top (open_subgroup G) := ‚ü®{ is_open' := is_open_univ, .. (‚ä§ : subgroup G) }‚ü©

@[to_additive]
instance : inhabited (open_subgroup G) := ‚ü®‚ä§‚ü©

@[to_additive]
lemma is_closed [topological_monoid G] (U : open_subgroup G) : is_closed (U : set G) :=
begin
  refine is_open_iff_forall_mem_open.2 (Œª x hx, ‚ü®(Œª y, y * x‚Åª¬π) ‚Åª¬π' U, _, _, _‚ü©),
  { intros u hux,
    simp only [set.mem_preimage, set.mem_compl_iff, mem_coe] at hux hx ‚ä¢,
    refine mt (Œª hu, _) hx,
    convert U.mul_mem (U.inv_mem hux) hu,
    simp },
  { exact (continuous_mul_right _) _ U.is_open },
  { simp [U.one_mem] }
end

section
variables {H : Type*} [group H] [topological_space H]

@[to_additive]
def prod (U : open_subgroup G) (V : open_subgroup H) : open_subgroup (G √ó H) :=
{ carrier := (U : set G).prod (V : set H),
  is_open' := is_open_prod U.is_open V.is_open,
  .. (U : subgroup G).prod (V : subgroup H) }

end

@[to_additive]
instance : partial_order (open_subgroup G) :=
{ le := Œª U V, ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà U ‚Üí x ‚àà V,
  .. partial_order.lift (coe : open_subgroup G ‚Üí set G) coe_injective }

@[to_additive]
instance : semilattice_inf_top (open_subgroup G) :=
{ inf := Œª U V, { is_open' := is_open_inter U.is_open V.is_open, .. (U : subgroup G) ‚äì V },
  inf_le_left := Œª U V, set.inter_subset_left _ _,
  inf_le_right := Œª U V, set.inter_subset_right _ _,
  le_inf := Œª U V W hV hW, set.subset_inter hV hW,
  top := ‚ä§,
  le_top := Œª U, set.subset_univ _,
  ..open_subgroup.partial_order }

@[simp, to_additive] lemma coe_inf : (‚Üë(U ‚äì V) : set G) = (U : set G) ‚à© V := rfl

@[simp, to_additive] lemma coe_subset : (U : set G) ‚äÜ V ‚Üî U ‚â§ V := iff.rfl

@[simp, to_additive] lemma coe_subgroup_le : (U : subgroup G) ‚â§ (V : subgroup G) ‚Üî U ‚â§ V := iff.rfl

attribute [norm_cast] coe_inf coe_subset coe_subgroup_le open_add_subgroup.coe_inf
  open_add_subgroup.coe_subset open_add_subgroup.coe_subgroup_le

end open_subgroup

namespace subgroup

variables {G : Type*} [group G] [topological_space G] [topological_monoid G] (H : subgroup G)

@[to_additive]
lemma is_open_of_mem_nhds {g : G} (hg : (H : set G) ‚àà ùìù g) :
  is_open (H : set G) :=
begin
  simp only [is_open_iff_mem_nhds, subgroup.mem_coe] at hg ‚ä¢,
  intros x hx,
  have : filter.tendsto (Œª y, y * (x‚Åª¬π * g)) (ùìù x) (ùìù $ x * (x‚Åª¬π * g)) :=
    (continuous_id.mul continuous_const).tendsto _,
  rw [mul_inv_cancel_left] at this,
  have := filter.mem_map.1 (this hg),
  replace hg : g ‚àà H := subgroup.mem_coe.1 (mem_of_nhds hg),
  simp only [subgroup.mem_coe, H.mul_mem_cancel_right (H.mul_mem (H.inv_mem hx) hg)] at this,
  exact this
end

@[to_additive is_open_of_open_add_subgroup]
lemma is_open_of_open_subgroup {U : open_subgroup G} (h : U.1 ‚â§ H) :
  is_open (H : set G) :=
H.is_open_of_mem_nhds (filter.mem_sets_of_superset U.mem_nhds_one h)

@[to_additive]
lemma is_open_mono {H‚ÇÅ H‚ÇÇ : subgroup G} (h : H‚ÇÅ ‚â§ H‚ÇÇ) (h‚ÇÅ : is_open (H‚ÇÅ  :set G)) :
  is_open (H‚ÇÇ : set G) :=
@is_open_of_open_subgroup _ _ _ _ H‚ÇÇ { is_open' := h‚ÇÅ, .. H‚ÇÅ } h

end subgroup

namespace open_subgroup

variables {G : Type*} [group G] [topological_space G] [topological_monoid G]

@[to_additive]
instance : semilattice_sup_top (open_subgroup G) :=
{ sup := Œª U V,
  { is_open' := show is_open (((U : subgroup G) ‚äî V : subgroup G) : set G),
    from subgroup.is_open_mono le_sup_left U.is_open,
    .. ((U : subgroup G) ‚äî V) },
  le_sup_left := Œª U V, coe_subgroup_le.1 le_sup_left,
  le_sup_right := Œª U V, coe_subgroup_le.1 le_sup_right,
  sup_le := Œª U V W hU hV, coe_subgroup_le.1 (sup_le hU hV),
  ..open_subgroup.semilattice_inf_top }

end open_subgroup

namespace submodule
open open_add_subgroup
variables {R : Type*} {M : Type*} [comm_ring R]
variables [add_comm_group M] [topological_space M] [topological_add_group M] [module R M]

lemma is_open_mono {U P : submodule R M} (h : U ‚â§ P) (hU : is_open (U : set M)) :
  is_open (P : set M) :=
@add_subgroup.is_open_mono M _ _ _ U.to_add_subgroup P.to_add_subgroup h hU

end submodule

namespace ideal
variables {R : Type*} [comm_ring R]
variables [topological_space R] [topological_ring R]

lemma is_open_of_open_subideal {U I : ideal R} (h : U ‚â§ I) (hU : is_open (U : set R)) :
  is_open (I : set R) :=
submodule.is_open_mono h hU

end ideal
