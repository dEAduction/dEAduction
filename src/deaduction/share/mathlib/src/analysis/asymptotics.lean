/-
Copyright (c) 2019 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Yury Kudryashov
-/
import analysis.normed_space.basic
import topology.local_homeomorph

/-!
# Asymptotics

We introduce these relations:

* `is_O_with c f g l` : "f is big O of g along l with constant c";
* `is_O f g l` : "f is big O of g along l";
* `is_o f g l` : "f is little o of g along l".

Here `l` is any filter on the domain of `f` and `g`, which are assumed to be the same. The codomains
of `f` and `g` do not need to be the same; all that is needed that there is a norm associated with
these types, and it is the norm that is compared asymptotically.

The relation `is_O_with c` is introduced to factor out common algebraic arguments in the proofs of
similar properties of `is_O` and `is_o`. Usually proofs outside of this file should use `is_O`
instead.

Often the ranges of `f` and `g` will be the real numbers, in which case the norm is the absolute
value. In general, we have

  `is_O f g l ‚Üî is_O (Œª x, ‚à•f x‚à•) (Œª x, ‚à•g x‚à•) l`,

and similarly for `is_o`. But our setup allows us to use the notions e.g. with functions
to the integers, rationals, complex numbers, or any normed vector space without mentioning the
norm explicitly.

If `f` and `g` are functions to a normed field like the reals or complex numbers and `g` is always
nonzero, we have

  `is_o f g l ‚Üî tendsto (Œª x, f x / (g x)) l (ùìù 0)`.

In fact, the right-to-left direction holds without the hypothesis on `g`, and in the other direction
it suffices to assume that `f` is zero wherever `g` is. (This generalization is useful in defining
the Fr√©chet derivative.)
-/

open filter set
open_locale topological_space big_operators classical

namespace asymptotics

variables {Œ± : Type*} {Œ≤ : Type*} {E : Type*} {F : Type*} {G : Type*}
  {E' : Type*} {F' : Type*} {G' : Type*} {R : Type*} {R' : Type*} {ùïú : Type*} {ùïú' : Type*}

variables [has_norm E] [has_norm F] [has_norm G] [normed_group E'] [normed_group F']
  [normed_group G'] [normed_ring R] [normed_ring R'] [normed_field ùïú] [normed_field ùïú']
  {c c' : ‚Ñù} {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {k : Œ± ‚Üí G} {f' : Œ± ‚Üí E'} {g' : Œ± ‚Üí F'} {k' : Œ± ‚Üí G'}
  {l l' : filter Œ±}

section defs

/-! ### Definitions -/

/-- This version of the Landau notation `is_O_with C f g l` where `f` and `g` are two functions on
a type `Œ±` and `l` is a filter on `Œ±`, means that eventually for `l`, `‚à•f‚à•` is bounded by `C * ‚à•g‚à•`.
In other words, `‚à•f‚à• / ‚à•g‚à•` is eventually bounded by `C`, modulo division by zero issues that are
avoided by this definition. Probably you want to use `is_O` instead of this relation. -/
def is_O_with (c : ‚Ñù) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) (l : filter Œ±) : Prop :=
‚àÄ·∂† x in l, ‚à• f x ‚à• ‚â§ c * ‚à• g x ‚à•

/-- Definition of `is_O_with`. We record it in a lemma as we will set `is_O_with` to be irreducible
at the end of this file. -/
lemma is_O_with_iff {c : ‚Ñù} {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±} :
  is_O_with c f g l ‚Üî ‚àÄ·∂† x in l, ‚à• f x ‚à• ‚â§ c * ‚à• g x ‚à• := iff.rfl

lemma is_O_with.of_bound {c : ‚Ñù} {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±}
  (h : ‚àÄ·∂† x in l, ‚à• f x ‚à• ‚â§ c * ‚à• g x ‚à•) : is_O_with c f g l := h

/-- The Landau notation `is_O f g l` where `f` and `g` are two functions on a type `Œ±` and `l` is
a filter on `Œ±`, means that eventually for `l`, `‚à•f‚à•` is bounded by a constant multiple of `‚à•g‚à•`.
In other words, `‚à•f‚à• / ‚à•g‚à•` is eventually bounded, modulo division by zero issues that are avoided
by this definition. -/
def is_O (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) (l : filter Œ±) : Prop := ‚àÉ c : ‚Ñù, is_O_with c f g l

/-- Definition of `is_O` in terms of `is_O_with`. We record it in a lemma as we will set
`is_O` to be irreducible at the end of this file. -/
lemma is_O_iff_is_O_with {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±} :
  is_O f g l ‚Üî ‚àÉ c : ‚Ñù, is_O_with c f g l := iff.rfl

/-- Definition of `is_O` in terms of filters. We record it in a lemma as we will set
`is_O` to be irreducible at the end of this file. -/
lemma is_O_iff {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±} :
  is_O f g l ‚Üî ‚àÉ c : ‚Ñù, ‚àÄ·∂† x in l, ‚à• f x ‚à• ‚â§ c * ‚à• g x ‚à• := iff.rfl

lemma is_O.of_bound (c : ‚Ñù) {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±}
  (h : ‚àÄ·∂† x in l, ‚à• f x ‚à• ‚â§ c * ‚à• g x ‚à•) : is_O f g l := ‚ü®c, h‚ü©

/-- The Landau notation `is_o f g l` where `f` and `g` are two functions on a type `Œ±` and `l` is
a filter on `Œ±`, means that eventually for `l`, `‚à•f‚à•` is bounded by an arbitrarily small constant
multiple of `‚à•g‚à•`. In other words, `‚à•f‚à• / ‚à•g‚à•` tends to `0` along `l`, modulo division by zero
issues that are avoided by this definition. -/
def is_o (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) (l : filter Œ±) : Prop := ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí is_O_with c f g l

/-- Definition of `is_o` in terms of `is_O_with`. We record it in a lemma as we will set
`is_o` to be irreducible at the end of this file. -/
lemma is_o_iff_forall_is_O_with {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±} :
  is_o f g l ‚Üî ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí is_O_with c f g l := iff.rfl

/-- Definition of `is_o` in terms of filters. We record it in a lemma as we will set
`is_o` to be irreducible at the end of this file. -/
lemma is_o_iff {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±} :
  is_o f g l ‚Üî ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí ‚àÄ·∂† x in l, ‚à• f x ‚à• ‚â§ c * ‚à• g x ‚à• := iff.rfl

lemma is_o.def {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±} (h : is_o f g l) {c : ‚Ñù} (hc : 0 < c) :
  ‚àÄ·∂† x in l, ‚à• f x ‚à• ‚â§ c * ‚à• g x ‚à• :=
h hc

lemma is_o.def' {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±} (h : is_o f g l) {c : ‚Ñù} (hc : 0 < c) :
  is_O_with c f g l :=
h hc

end defs

/-! ### Conversions -/

theorem is_O_with.is_O (h : is_O_with c f g l) : is_O f g l := ‚ü®c, h‚ü©

theorem is_o.is_O_with (hgf : is_o f g l) : is_O_with 1 f g l := hgf zero_lt_one

theorem is_o.is_O (hgf : is_o f g l) : is_O f g l := hgf.is_O_with.is_O

theorem is_O_with.weaken (h : is_O_with c f g' l) (hc : c ‚â§ c') : is_O_with c' f g' l :=
mem_sets_of_superset h $ Œª x hx,
calc ‚à•f x‚à• ‚â§ c * ‚à•g' x‚à• : hx
... ‚â§ _ : mul_le_mul_of_nonneg_right hc (norm_nonneg _)

theorem is_O_with.exists_pos (h : is_O_with c f g' l) :
  ‚àÉ c' (H : 0 < c'), is_O_with c' f g' l :=
‚ü®max c 1, lt_of_lt_of_le zero_lt_one (le_max_right c 1), h.weaken $ le_max_left c 1‚ü©

theorem is_O.exists_pos (h : is_O f g' l) : ‚àÉ c (H : 0 < c), is_O_with c f g' l :=
let ‚ü®c, hc‚ü© := h in hc.exists_pos

theorem is_O_with.exists_nonneg (h : is_O_with c f g' l) :
  ‚àÉ c' (H : 0 ‚â§ c'), is_O_with c' f g' l :=
let ‚ü®c, cpos, hc‚ü© := h.exists_pos in ‚ü®c, le_of_lt cpos, hc‚ü©

theorem is_O.exists_nonneg (h : is_O f g' l) :
  ‚àÉ c (H : 0 ‚â§ c), is_O_with c f g' l :=
let ‚ü®c, hc‚ü© := h in hc.exists_nonneg

/-! ### Congruence -/

theorem is_O_with_congr {c‚ÇÅ c‚ÇÇ} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F} {l : filter Œ±}
  (hc : c‚ÇÅ = c‚ÇÇ) (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) :
  is_O_with c‚ÇÅ f‚ÇÅ g‚ÇÅ l ‚Üî is_O_with c‚ÇÇ f‚ÇÇ g‚ÇÇ l :=
begin
  subst c‚ÇÇ,
  apply filter.congr_sets,
  filter_upwards [hf, hg],
  assume x e‚ÇÅ e‚ÇÇ,
  dsimp at e‚ÇÅ e‚ÇÇ ‚ä¢,
  rw [e‚ÇÅ, e‚ÇÇ]
end

theorem is_O_with.congr' {c‚ÇÅ c‚ÇÇ} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F} {l : filter Œ±}
  (hc : c‚ÇÅ = c‚ÇÇ) (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) :
  is_O_with c‚ÇÅ f‚ÇÅ g‚ÇÅ l ‚Üí is_O_with c‚ÇÇ f‚ÇÇ g‚ÇÇ l :=
(is_O_with_congr hc hf hg).mp

theorem is_O_with.congr {c‚ÇÅ c‚ÇÇ} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F} {l : filter Œ±}
  (hc : c‚ÇÅ = c‚ÇÇ) (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x) (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) :
  is_O_with c‚ÇÅ f‚ÇÅ g‚ÇÅ l ‚Üí is_O_with c‚ÇÇ f‚ÇÇ g‚ÇÇ l :=
Œª h, h.congr' hc (univ_mem_sets' hf) (univ_mem_sets' hg)

theorem is_O_with.congr_left {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {l : filter Œ±} (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x) :
  is_O_with c f‚ÇÅ g l ‚Üí is_O_with c f‚ÇÇ g l :=
is_O_with.congr rfl hf (Œª _, rfl)

theorem is_O_with.congr_right {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F} {l : filter Œ±} (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) :
  is_O_with c f g‚ÇÅ l ‚Üí is_O_with c f g‚ÇÇ l :=
is_O_with.congr rfl (Œª _, rfl) hg

theorem is_O_with.congr_const {c‚ÇÅ c‚ÇÇ} {l : filter Œ±} (hc : c‚ÇÅ = c‚ÇÇ) :
  is_O_with c‚ÇÅ f g l ‚Üí is_O_with c‚ÇÇ f g l :=
is_O_with.congr hc (Œª _, rfl) (Œª _, rfl)

theorem is_O_congr {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F} {l : filter Œ±}
    (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) :
  is_O f‚ÇÅ g‚ÇÅ l ‚Üî is_O f‚ÇÇ g‚ÇÇ l :=
exists_congr $ Œª c, is_O_with_congr rfl hf hg

theorem is_O.congr' {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F} {l : filter Œ±}
    (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) :
  is_O f‚ÇÅ g‚ÇÅ l ‚Üí is_O f‚ÇÇ g‚ÇÇ l :=
(is_O_congr hf hg).mp

theorem is_O.congr {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F} {l : filter Œ±}
    (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x) (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) :
  is_O f‚ÇÅ g‚ÇÅ l ‚Üí is_O f‚ÇÇ g‚ÇÇ l :=
Œª h, h.congr' (univ_mem_sets' hf) (univ_mem_sets' hg)

theorem is_O.congr_left {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {l : filter Œ±} (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x) :
  is_O f‚ÇÅ g l ‚Üí is_O f‚ÇÇ g l :=
is_O.congr hf (Œª _, rfl)

theorem is_O.congr_right {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí E} {l : filter Œ±} (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) :
  is_O f g‚ÇÅ l ‚Üí is_O f g‚ÇÇ l :=
is_O.congr (Œª _, rfl) hg

theorem is_o_congr {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F} {l : filter Œ±}
    (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) :
  is_o f‚ÇÅ g‚ÇÅ l ‚Üî is_o f‚ÇÇ g‚ÇÇ l :=
ball_congr (Œª c hc, is_O_with_congr (eq.refl c) hf hg)

theorem is_o.congr' {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F} {l : filter Œ±}
    (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) :
  is_o f‚ÇÅ g‚ÇÅ l ‚Üí is_o f‚ÇÇ g‚ÇÇ l :=
(is_o_congr hf hg).mp

theorem is_o.congr {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F} {l : filter Œ±}
    (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x) (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) :
  is_o f‚ÇÅ g‚ÇÅ l ‚Üí is_o f‚ÇÇ g‚ÇÇ l :=
Œª h, h.congr' (univ_mem_sets' hf) (univ_mem_sets' hg)

theorem is_o.congr_left {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {l : filter Œ±} (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x) :
  is_o f‚ÇÅ g l ‚Üí is_o f‚ÇÇ g l :=
is_o.congr hf (Œª _, rfl)

theorem is_o.congr_right {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí E} {l : filter Œ±} (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) :
  is_o f g‚ÇÅ l ‚Üí is_o f g‚ÇÇ l :=
is_o.congr (Œª _, rfl) hg

/-! ### Filter operations and transitivity -/

theorem is_O_with.comp_tendsto (hcfg : is_O_with c f g l)
  {k : Œ≤ ‚Üí Œ±} {l' : filter Œ≤} (hk : tendsto k l' l):
  is_O_with c (f ‚àò k) (g ‚àò k) l' :=
hk hcfg

theorem is_O.comp_tendsto (hfg : is_O f g l) {k : Œ≤ ‚Üí Œ±} {l' : filter Œ≤} (hk : tendsto k l' l) :
  is_O (f ‚àò k) (g ‚àò k) l' :=
hfg.imp (Œª c h, h.comp_tendsto hk)

theorem is_o.comp_tendsto (hfg : is_o f g l) {k : Œ≤ ‚Üí Œ±} {l' : filter Œ≤} (hk : tendsto k l' l) :
  is_o (f ‚àò k) (g ‚àò k) l' :=
Œª c cpos, (hfg cpos).comp_tendsto hk

theorem is_O_with.mono (h : is_O_with c f g l') (hl : l ‚â§ l') : is_O_with c f g l :=
hl h

theorem is_O.mono (h : is_O f g l') (hl : l ‚â§ l') : is_O f g l :=
h.imp (Œª c h, h.mono hl)

theorem is_o.mono (h : is_o f g l') (hl : l ‚â§ l') : is_o f g l :=
Œª c cpos, (h cpos).mono hl

theorem is_O_with.trans (hfg : is_O_with c f g l) (hgk : is_O_with c' g k l) (hc : 0 ‚â§ c) :
  is_O_with (c * c') f k l :=
begin
  filter_upwards [hfg, hgk],
  assume x hx hx',
  calc ‚à•f x‚à• ‚â§ c * ‚à•g x‚à• : hx
  ... ‚â§ c * (c' * ‚à•k x‚à•) : mul_le_mul_of_nonneg_left hx' hc
  ... = c * c' * ‚à•k x‚à• : (mul_assoc _ _ _).symm
end

theorem is_O.trans (hfg : is_O f g' l) (hgk : is_O g' k l) : is_O f k l :=
let ‚ü®c, cnonneg, hc‚ü© := hfg.exists_nonneg, ‚ü®c', hc'‚ü© := hgk in (hc.trans hc' cnonneg).is_O

theorem is_o.trans_is_O_with (hfg : is_o f g l) (hgk : is_O_with c g k l) (hc : 0 < c) :
  is_o f k l :=
begin
  intros c' c'pos,
  have : 0 < c' / c, from div_pos c'pos hc,
  exact ((hfg this).trans hgk (le_of_lt this)).congr_const (div_mul_cancel _ (ne_of_gt hc))
end

theorem is_o.trans_is_O (hfg : is_o f g l) (hgk : is_O g k' l) : is_o f k' l :=
let ‚ü®c, cpos, hc‚ü© := hgk.exists_pos in hfg.trans_is_O_with hc cpos

theorem is_O_with.trans_is_o (hfg : is_O_with c f g l) (hgk : is_o g k l) (hc : 0 < c) :
  is_o f k l :=
begin
  intros c' c'pos,
  have : 0 < c' / c, from div_pos c'pos hc,
  exact (hfg.trans (hgk this) (le_of_lt hc)).congr_const (mul_div_cancel' _ (ne_of_gt hc))
end

theorem is_O.trans_is_o (hfg : is_O f g' l) (hgk : is_o g' k l) : is_o f k l :=
let ‚ü®c, cpos, hc‚ü© := hfg.exists_pos in hc.trans_is_o hgk cpos

theorem is_o.trans (hfg : is_o f g l) (hgk : is_o g k' l) : is_o f k' l :=
hfg.trans_is_O hgk.is_O

theorem is_o.trans' (hfg : is_o f g' l) (hgk : is_o g' k l) : is_o f k l :=
hfg.is_O.trans_is_o hgk

section

variable (l)

theorem is_O_with_of_le' (hfg : ‚àÄ x, ‚à•f x‚à• ‚â§ c * ‚à•g x‚à•) : is_O_with c f g l :=
univ_mem_sets' hfg

theorem is_O_with_of_le (hfg : ‚àÄ x, ‚à•f x‚à• ‚â§ ‚à•g x‚à•) : is_O_with 1 f g l :=
is_O_with_of_le' l $ Œª x, by { rw one_mul, exact hfg x }

theorem is_O_of_le' (hfg : ‚àÄ x, ‚à•f x‚à• ‚â§ c * ‚à•g x‚à•) : is_O f g l :=
(is_O_with_of_le' l hfg).is_O

theorem is_O_of_le (hfg : ‚àÄ x, ‚à•f x‚à• ‚â§ ‚à•g x‚à•) : is_O f g l :=
(is_O_with_of_le l hfg).is_O

end

theorem is_O_with_refl (f : Œ± ‚Üí E) (l : filter Œ±) : is_O_with 1 f f l :=
is_O_with_of_le l $ Œª _, le_refl _

theorem is_O_refl (f : Œ± ‚Üí E) (l : filter Œ±) : is_O f f l := (is_O_with_refl f l).is_O

theorem is_O_with.trans_le (hfg : is_O_with c f g l) (hgk : ‚àÄ x, ‚à•g x‚à• ‚â§ ‚à•k x‚à•) (hc : 0 ‚â§ c) :
  is_O_with c f k l :=
(hfg.trans (is_O_with_of_le l hgk) hc).congr_const $ mul_one c

theorem is_O.trans_le (hfg : is_O f g' l) (hgk : ‚àÄ x, ‚à•g' x‚à• ‚â§ ‚à•k x‚à•) :
  is_O f k l :=
hfg.trans (is_O_of_le l hgk)

section bot

variables (c f g)

theorem is_O_with_bot : is_O_with c f g ‚ä• := trivial

theorem is_O_bot : is_O f g ‚ä• := (is_O_with_bot c f g).is_O

theorem is_o_bot : is_o f g ‚ä• := Œª c _, is_O_with_bot c f g

end bot

theorem is_O_with.join (h : is_O_with c f g l) (h' : is_O_with c f g l') :
  is_O_with c f g (l ‚äî l') :=
mem_sup_sets.2 ‚ü®h, h'‚ü©

theorem is_O_with.join' (h : is_O_with c f g' l) (h' : is_O_with c' f g' l') :
  is_O_with (max c c') f g' (l ‚äî l') :=
mem_sup_sets.2 ‚ü®(h.weaken $ le_max_left c c'), (h'.weaken $ le_max_right c c')‚ü©

theorem is_O.join (h : is_O f g' l) (h' : is_O f g' l') : is_O f g' (l ‚äî l') :=
let ‚ü®c, hc‚ü© := h, ‚ü®c', hc'‚ü© := h' in (hc.join' hc').is_O

theorem is_o.join (h : is_o f g l) (h' : is_o f g l') :
  is_o f g (l ‚äî l') :=
Œª c cpos, (h cpos).join (h' cpos)

/-! ### Simplification : norm -/

@[simp] theorem is_O_with_norm_right : is_O_with c f (Œª x, ‚à•g' x‚à•) l ‚Üî is_O_with c f g' l :=
by simp only [is_O_with, norm_norm]

alias is_O_with_norm_right ‚Üî asymptotics.is_O_with.of_norm_right asymptotics.is_O_with.norm_right

@[simp] theorem is_O_norm_right : is_O f (Œª x, ‚à•g' x‚à•) l ‚Üî is_O f g' l :=
exists_congr $ Œª _,  is_O_with_norm_right

alias is_O_norm_right ‚Üî asymptotics.is_O.of_norm_right asymptotics.is_O.norm_right

@[simp] theorem is_o_norm_right : is_o f (Œª x, ‚à•g' x‚à•) l ‚Üî is_o f g' l :=
forall_congr $ Œª _, forall_congr $ Œª _, is_O_with_norm_right

alias is_o_norm_right ‚Üî asymptotics.is_o.of_norm_right asymptotics.is_o.norm_right

@[simp] theorem is_O_with_norm_left : is_O_with c (Œª x, ‚à•f' x‚à•) g l ‚Üî is_O_with c f' g l :=
by simp only [is_O_with, norm_norm]

alias is_O_with_norm_left ‚Üî asymptotics.is_O_with.of_norm_left asymptotics.is_O_with.norm_left

@[simp] theorem is_O_norm_left : is_O (Œª x, ‚à•f' x‚à•) g l ‚Üî is_O f' g l :=
exists_congr $ Œª _, is_O_with_norm_left

alias is_O_norm_left ‚Üî asymptotics.is_O.of_norm_left asymptotics.is_O.norm_left

@[simp] theorem is_o_norm_left : is_o (Œª x, ‚à•f' x‚à•) g l ‚Üî is_o f' g l :=
forall_congr $ Œª _, forall_congr $ Œª _, is_O_with_norm_left

alias is_o_norm_left ‚Üî asymptotics.is_o.of_norm_left asymptotics.is_o.norm_left

theorem is_O_with_norm_norm :
  is_O_with c (Œª x, ‚à•f' x‚à•) (Œª x, ‚à•g' x‚à•) l ‚Üî is_O_with c f' g' l :=
is_O_with_norm_left.trans is_O_with_norm_right

alias is_O_with_norm_norm ‚Üî asymptotics.is_O_with.of_norm_norm asymptotics.is_O_with.norm_norm

theorem is_O_norm_norm :
  is_O (Œª x, ‚à•f' x‚à•) (Œª x, ‚à•g' x‚à•) l ‚Üî is_O f' g' l :=
is_O_norm_left.trans is_O_norm_right

alias is_O_norm_norm ‚Üî asymptotics.is_O.of_norm_norm asymptotics.is_O.norm_norm

theorem is_o_norm_norm :
  is_o (Œª x, ‚à•f' x‚à•) (Œª x, ‚à•g' x‚à•) l ‚Üî is_o f' g' l :=
is_o_norm_left.trans is_o_norm_right

alias is_o_norm_norm ‚Üî asymptotics.is_o.of_norm_norm asymptotics.is_o.norm_norm

/-! ### Simplification: negate -/

@[simp] theorem is_O_with_neg_right : is_O_with c f (Œª x, -(g' x)) l ‚Üî is_O_with c f g' l :=
by simp only [is_O_with, norm_neg]

alias is_O_with_neg_right ‚Üî asymptotics.is_O_with.of_neg_right asymptotics.is_O_with.neg_right

@[simp] theorem is_O_neg_right : is_O f (Œª x, -(g' x)) l ‚Üî is_O f g' l :=
exists_congr $ Œª _, is_O_with_neg_right

alias is_O_neg_right ‚Üî asymptotics.is_O.of_neg_right asymptotics.is_O.neg_right

@[simp] theorem is_o_neg_right : is_o f (Œª x, -(g' x)) l ‚Üî is_o f g' l :=
forall_congr $ Œª _, forall_congr $ Œª _, is_O_with_neg_right

alias is_o_neg_right ‚Üî asymptotics.is_o.of_neg_right asymptotics.is_o.neg_right

@[simp] theorem is_O_with_neg_left : is_O_with c (Œª x, -(f' x)) g l ‚Üî is_O_with c f' g l :=
by simp only [is_O_with, norm_neg]

alias is_O_with_neg_left ‚Üî asymptotics.is_O_with.of_neg_left asymptotics.is_O_with.neg_left

@[simp] theorem is_O_neg_left : is_O (Œª x, -(f' x)) g l ‚Üî is_O f' g l :=
exists_congr $ Œª _, is_O_with_neg_left

alias is_O_neg_left ‚Üî asymptotics.is_O.of_neg_left asymptotics.is_O.neg_left

@[simp] theorem is_o_neg_left : is_o (Œª x, -(f' x)) g l ‚Üî is_o f' g l :=
forall_congr $ Œª _, forall_congr $ Œª _, is_O_with_neg_left

alias is_o_neg_left ‚Üî asymptotics.is_o.of_neg_right asymptotics.is_o.neg_left

/-! ### Product of functions (right) -/

lemma is_O_with_fst_prod : is_O_with 1 f' (Œª x, (f' x, g' x)) l :=
is_O_with_of_le l $ Œª x, le_max_left _ _

lemma is_O_with_snd_prod : is_O_with 1 g' (Œª x, (f' x, g' x)) l :=
is_O_with_of_le l $ Œª x, le_max_right _ _

lemma is_O_fst_prod : is_O f' (Œª x, (f' x, g' x)) l := is_O_with_fst_prod.is_O

lemma is_O_snd_prod : is_O g' (Œª x, (f' x, g' x)) l := is_O_with_snd_prod.is_O

lemma is_O_fst_prod' {f' : Œ± ‚Üí E' √ó F'} : is_O (Œª x, (f' x).1) f' l :=
is_O_fst_prod

lemma is_O_snd_prod' {f' : Œ± ‚Üí E' √ó F'} : is_O (Œª x, (f' x).2) f' l :=
is_O_snd_prod

section

variables (f' k')

lemma is_O_with.prod_rightl (h : is_O_with c f g' l) (hc : 0 ‚â§ c) :
  is_O_with c f (Œª x, (g' x, k' x)) l :=
(h.trans is_O_with_fst_prod hc).congr_const (mul_one c)

lemma is_O.prod_rightl (h : is_O f g' l) : is_O f (Œªx, (g' x, k' x)) l :=
let ‚ü®c, cnonneg, hc‚ü© := h.exists_nonneg in (hc.prod_rightl k' cnonneg).is_O

lemma is_o.prod_rightl (h : is_o f g' l) : is_o f (Œª x, (g' x, k' x)) l :=
Œª c cpos, (h cpos).prod_rightl k' (le_of_lt cpos)

lemma is_O_with.prod_rightr (h : is_O_with c f g' l) (hc : 0 ‚â§ c) :
  is_O_with c f (Œª x, (f' x, g' x)) l :=
(h.trans is_O_with_snd_prod hc).congr_const (mul_one c)

lemma is_O.prod_rightr (h : is_O f g' l) : is_O f (Œªx, (f' x, g' x)) l :=
let ‚ü®c, cnonneg, hc‚ü© := h.exists_nonneg in (hc.prod_rightr f' cnonneg).is_O

lemma is_o.prod_rightr (h : is_o f g' l) : is_o f (Œªx, (f' x, g' x)) l :=
Œª c cpos, (h cpos).prod_rightr f' (le_of_lt cpos)

end

lemma is_O_with.prod_left_same (hf : is_O_with c f' k' l) (hg : is_O_with c g' k' l) :
  is_O_with c (Œª x, (f' x, g' x)) k' l :=
begin
  filter_upwards [hf, hg],
  simp only [mem_set_of_eq],
  exact Œª x, max_le
end

lemma is_O_with.prod_left (hf : is_O_with c f' k' l) (hg : is_O_with c' g' k' l) :
  is_O_with (max c c') (Œª x, (f' x, g' x)) k' l :=
(hf.weaken $ le_max_left c c').prod_left_same (hg.weaken $ le_max_right c c')

lemma is_O_with.prod_left_fst (h : is_O_with c (Œª x, (f' x, g' x)) k' l) :
  is_O_with c f' k' l :=
(is_O_with_fst_prod.trans h zero_le_one).congr_const $ one_mul c

lemma is_O_with.prod_left_snd (h : is_O_with c (Œª x, (f' x, g' x)) k' l) :
  is_O_with c g' k' l :=
(is_O_with_snd_prod.trans h zero_le_one).congr_const $ one_mul c

lemma is_O_with_prod_left :
   is_O_with c (Œª x, (f' x, g' x)) k' l ‚Üî is_O_with c f' k' l ‚àß is_O_with c g' k' l :=
‚ü®Œª h, ‚ü®h.prod_left_fst, h.prod_left_snd‚ü©, Œª h, h.1.prod_left_same h.2‚ü©

lemma is_O.prod_left (hf : is_O f' k' l) (hg : is_O g' k' l) : is_O (Œª x, (f' x, g' x)) k' l :=
let ‚ü®c, hf‚ü© := hf, ‚ü®c', hg‚ü© := hg in (hf.prod_left hg).is_O

lemma is_O.prod_left_fst (h : is_O (Œª x, (f' x, g' x)) k' l) : is_O f' k' l :=
is_O_fst_prod.trans h

lemma is_O.prod_left_snd (h : is_O (Œª x, (f' x, g' x)) k' l) : is_O g' k' l :=
is_O_snd_prod.trans h

@[simp] lemma is_O_prod_left :
  is_O (Œª x, (f' x, g' x)) k' l ‚Üî is_O f' k' l ‚àß is_O g' k' l :=
‚ü®Œª h, ‚ü®h.prod_left_fst, h.prod_left_snd‚ü©, Œª h, h.1.prod_left h.2‚ü©

lemma is_o.prod_left (hf : is_o f' k' l) (hg : is_o g' k' l) : is_o (Œª x, (f' x, g' x)) k' l :=
Œª c hc, (hf hc).prod_left_same (hg hc)

lemma is_o.prod_left_fst (h : is_o (Œª x, (f' x, g' x)) k' l) : is_o f' k' l :=
is_O_fst_prod.trans_is_o h

lemma is_o.prod_left_snd (h : is_o (Œª x, (f' x, g' x)) k' l) : is_o g' k' l :=
is_O_snd_prod.trans_is_o h

@[simp] lemma is_o_prod_left :
  is_o (Œª x, (f' x, g' x)) k' l ‚Üî is_o f' k' l ‚àß is_o g' k' l :=
‚ü®Œª h, ‚ü®h.prod_left_fst, h.prod_left_snd‚ü©, Œª h, h.1.prod_left h.2‚ü©

/-! ### Addition and subtraction -/

section add_sub

variables {c‚ÇÅ c‚ÇÇ : ‚Ñù} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E'}

theorem is_O_with.add (h‚ÇÅ : is_O_with c‚ÇÅ f‚ÇÅ g l) (h‚ÇÇ : is_O_with c‚ÇÇ f‚ÇÇ g l) :
  is_O_with (c‚ÇÅ + c‚ÇÇ) (Œª x, f‚ÇÅ x + f‚ÇÇ x) g l :=
by filter_upwards [h‚ÇÅ, h‚ÇÇ] Œª x hx‚ÇÅ hx‚ÇÇ,
calc ‚à•f‚ÇÅ x + f‚ÇÇ x‚à• ‚â§ c‚ÇÅ * ‚à•g x‚à• + c‚ÇÇ * ‚à•g x‚à• : norm_add_le_of_le hx‚ÇÅ hx‚ÇÇ
               ... = (c‚ÇÅ + c‚ÇÇ) * ‚à•g x‚à•       : (add_mul _ _ _).symm

theorem is_O.add : is_O f‚ÇÅ g l ‚Üí is_O f‚ÇÇ g l ‚Üí is_O (Œª x, f‚ÇÅ x + f‚ÇÇ x) g l
| ‚ü®c‚ÇÅ, hc‚ÇÅ‚ü© ‚ü®c‚ÇÇ, hc‚ÇÇ‚ü© := (hc‚ÇÅ.add hc‚ÇÇ).is_O

theorem is_o.add (h‚ÇÅ : is_o f‚ÇÅ g l) (h‚ÇÇ : is_o f‚ÇÇ g l) : is_o (Œª x, f‚ÇÅ x + f‚ÇÇ x) g l :=
Œª c cpos, ((h‚ÇÅ $ half_pos cpos).add (h‚ÇÇ $ half_pos cpos)).congr_const (add_halves c)

theorem is_O.add_is_o (h‚ÇÅ : is_O f‚ÇÅ g l) (h‚ÇÇ : is_o f‚ÇÇ g l) : is_O (Œª x, f‚ÇÅ x + f‚ÇÇ x) g l :=
h‚ÇÅ.add h‚ÇÇ.is_O

theorem is_o.add_is_O (h‚ÇÅ : is_o f‚ÇÅ g l) (h‚ÇÇ : is_O f‚ÇÇ g l) : is_O (Œª x, f‚ÇÅ x + f‚ÇÇ x) g l :=
h‚ÇÅ.is_O.add h‚ÇÇ

theorem is_O_with.add_is_o (h‚ÇÅ : is_O_with c‚ÇÅ f‚ÇÅ g l) (h‚ÇÇ : is_o f‚ÇÇ g l) (hc : c‚ÇÅ < c‚ÇÇ) :
  is_O_with c‚ÇÇ (Œªx, f‚ÇÅ x + f‚ÇÇ x) g l :=
(h‚ÇÅ.add (h‚ÇÇ (sub_pos.2 hc))).congr_const (add_sub_cancel'_right _ _)

theorem is_o.add_is_O_with (h‚ÇÅ : is_o f‚ÇÅ g l) (h‚ÇÇ : is_O_with c‚ÇÅ f‚ÇÇ g l) (hc : c‚ÇÅ < c‚ÇÇ) :
  is_O_with c‚ÇÇ (Œªx, f‚ÇÅ x + f‚ÇÇ x) g l :=
(h‚ÇÇ.add_is_o h‚ÇÅ hc).congr_left $ Œª _, add_comm _ _

theorem is_O_with.sub (h‚ÇÅ : is_O_with c‚ÇÅ f‚ÇÅ g l) (h‚ÇÇ : is_O_with c‚ÇÇ f‚ÇÇ g l) :
  is_O_with (c‚ÇÅ + c‚ÇÇ) (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l :=
h‚ÇÅ.add h‚ÇÇ.neg_left

theorem is_O_with.sub_is_o (h‚ÇÅ : is_O_with c‚ÇÅ f‚ÇÅ g l) (h‚ÇÇ : is_o f‚ÇÇ g l) (hc : c‚ÇÅ < c‚ÇÇ) :
  is_O_with c‚ÇÇ (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l :=
h‚ÇÅ.add_is_o h‚ÇÇ.neg_left hc

theorem is_O.sub (h‚ÇÅ : is_O f‚ÇÅ g l) (h‚ÇÇ : is_O f‚ÇÇ g l) : is_O (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l :=
h‚ÇÅ.add h‚ÇÇ.neg_left

theorem is_o.sub (h‚ÇÅ : is_o f‚ÇÅ g l) (h‚ÇÇ : is_o f‚ÇÇ g l) : is_o (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l :=
h‚ÇÅ.add h‚ÇÇ.neg_left

end add_sub

/-! ### Lemmas about `is_O (f‚ÇÅ - f‚ÇÇ) g l` / `is_o (f‚ÇÅ - f‚ÇÇ) g l` treated as a binary relation -/

section is_oO_as_rel

variables {f‚ÇÅ f‚ÇÇ f‚ÇÉ : Œ± ‚Üí E'}

theorem is_O_with.symm (h : is_O_with c (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l) :
  is_O_with c (Œª x, f‚ÇÇ x - f‚ÇÅ x) g l :=
h.neg_left.congr_left $ Œª x, neg_sub _ _

theorem is_O_with_comm :
  is_O_with c (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l ‚Üî is_O_with c (Œª x, f‚ÇÇ x - f‚ÇÅ x) g l :=
‚ü®is_O_with.symm, is_O_with.symm‚ü©

theorem is_O.symm (h : is_O (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l) : is_O (Œª x, f‚ÇÇ x - f‚ÇÅ x) g l :=
h.neg_left.congr_left $ Œª x, neg_sub _ _

theorem is_O_comm : is_O (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l ‚Üî is_O (Œª x, f‚ÇÇ x - f‚ÇÅ x) g l :=
‚ü®is_O.symm, is_O.symm‚ü©

theorem is_o.symm (h : is_o (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l) : is_o (Œª x, f‚ÇÇ x - f‚ÇÅ x) g l :=
by simpa only [neg_sub] using h.neg_left

theorem is_o_comm : is_o (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l ‚Üî is_o (Œª x, f‚ÇÇ x - f‚ÇÅ x) g l :=
‚ü®is_o.symm, is_o.symm‚ü©

theorem is_O_with.triangle (h‚ÇÅ : is_O_with c (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l)
  (h‚ÇÇ : is_O_with c' (Œª x, f‚ÇÇ x - f‚ÇÉ x) g l) :
  is_O_with (c + c') (Œª x, f‚ÇÅ x - f‚ÇÉ x) g l :=
(h‚ÇÅ.add h‚ÇÇ).congr_left $ Œª x, sub_add_sub_cancel _ _ _

theorem is_O.triangle (h‚ÇÅ : is_O (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l) (h‚ÇÇ : is_O (Œª x, f‚ÇÇ x - f‚ÇÉ x) g l) :
  is_O (Œª x, f‚ÇÅ x - f‚ÇÉ x) g l :=
(h‚ÇÅ.add h‚ÇÇ).congr_left $ Œª x, sub_add_sub_cancel _ _ _

theorem is_o.triangle (h‚ÇÅ : is_o (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l) (h‚ÇÇ : is_o (Œª x, f‚ÇÇ x - f‚ÇÉ x) g l) :
  is_o (Œª x, f‚ÇÅ x - f‚ÇÉ x) g l :=
(h‚ÇÅ.add h‚ÇÇ).congr_left $ Œª x, sub_add_sub_cancel _ _ _

theorem is_O.congr_of_sub (h : is_O (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l) :
  is_O f‚ÇÅ g l ‚Üî is_O f‚ÇÇ g l :=
‚ü®Œª h', (h'.sub h).congr_left (Œª x, sub_sub_cancel _ _),
 Œª h', (h.add h').congr_left (Œª x, sub_add_cancel _ _)‚ü©

theorem is_o.congr_of_sub (h : is_o (Œª x, f‚ÇÅ x - f‚ÇÇ x) g l) :
  is_o f‚ÇÅ g l ‚Üî is_o f‚ÇÇ g l :=
‚ü®Œª h', (h'.sub h).congr_left (Œª x, sub_sub_cancel _ _),
 Œª h', (h.add h').congr_left (Œª x, sub_add_cancel _ _)‚ü©

end is_oO_as_rel

/-! ### Zero, one, and other constants -/

section zero_const

variables (g g' l)

theorem is_o_zero : is_o (Œª x, (0 : E')) g' l :=
Œª c hc, univ_mem_sets' $ Œª x, by simpa using mul_nonneg (le_of_lt hc) (norm_nonneg $ g' x)

theorem is_O_with_zero (hc : 0 ‚â§ c) : is_O_with c (Œª x, (0 : E')) g' l :=
univ_mem_sets' $ Œª x, by simpa using mul_nonneg hc (norm_nonneg $ g' x)

theorem is_O_with_zero' : is_O_with 0 (Œª x, (0 : E')) g l :=
univ_mem_sets' $ Œª x, by simp

theorem is_O_zero : is_O (Œª x, (0 : E')) g l := ‚ü®0, is_O_with_zero' _ _‚ü©

theorem is_O_refl_left : is_O (Œª x, f' x - f' x) g' l :=
(is_O_zero g' l).congr_left $ Œª x, (sub_self _).symm

theorem is_o_refl_left : is_o (Œª x, f' x - f' x) g' l :=
(is_o_zero g' l).congr_left $ Œª x, (sub_self _).symm

variables {g g' l}

theorem is_O_with_zero_right_iff :
  is_O_with c f' (Œª x, (0 : F')) l ‚Üî ‚àÄ·∂† x in l, f' x = 0 :=
by simp only [is_O_with, exists_prop, true_and, norm_zero, mul_zero, norm_le_zero_iff]

theorem is_O_zero_right_iff : is_O f' (Œª x, (0 : F')) l ‚Üî ‚àÄ·∂† x in l, f' x = 0 :=
‚ü®Œª h, let ‚ü®c, hc‚ü© := h in  (is_O_with_zero_right_iff).1 hc,
  Œª h, (is_O_with_zero_right_iff.2 h : is_O_with 1 _ _ _).is_O‚ü©

theorem is_o_zero_right_iff :
  is_o f' (Œª x, (0 : F')) l ‚Üî ‚àÄ·∂† x in l, f' x = 0 :=
‚ü®Œª h, is_O_zero_right_iff.1 h.is_O,
  Œª h c hc, is_O_with_zero_right_iff.2 h‚ü©

theorem is_O_with_const_const (c : E) {c' : F'} (hc' : c' ‚â† 0) (l : filter Œ±) :
  is_O_with (‚à•c‚à• / ‚à•c'‚à•) (Œª x : Œ±, c) (Œª x, c') l :=
begin
  apply univ_mem_sets',
  intro x,
  rw [mem_set_of_eq, div_mul_cancel],
  rwa [ne.def, norm_eq_zero]
end

theorem is_O_const_const (c : E) {c' : F'} (hc' : c' ‚â† 0) (l : filter Œ±) :
  is_O (Œª x : Œ±, c) (Œª x, c') l :=
(is_O_with_const_const c hc' l).is_O

end zero_const

theorem is_O_with_const_one (c : E) (l : filter Œ±) : is_O_with ‚à•c‚à• (Œª x : Œ±, c) (Œª x, (1 : ùïú)) l :=
begin
  refine (is_O_with_const_const c _ l).congr_const _,
  { rw [normed_field.norm_one, div_one] },
  { exact one_ne_zero }
end

theorem is_O_const_one (c : E) (l : filter Œ±) : is_O (Œª x : Œ±, c) (Œª x, (1 : ùïú)) l :=
(is_O_with_const_one c l).is_O

section

variable (ùïú)

theorem is_o_const_iff_is_o_one {c : F'} (hc : c ‚â† 0) :
  is_o f (Œª x, c) l ‚Üî is_o f (Œª x, (1:ùïú)) l :=
‚ü®Œª h, h.trans_is_O $ is_O_const_one c l, Œª h, h.trans_is_O $ is_O_const_const _ hc _‚ü©

end

theorem is_o_const_iff {c : F'} (hc : c ‚â† 0) :
  is_o f' (Œª x, c) l ‚Üî tendsto f' l (ùìù 0) :=
(is_o_const_iff_is_o_one ‚Ñù hc).trans
begin
  clear hc c,
  simp only [is_o, is_O_with, normed_field.norm_one, mul_one,
    metric.nhds_basis_closed_ball.tendsto_right_iff, metric.mem_closed_ball, dist_zero_right]
end

theorem is_O_const_of_tendsto {y : E'} (h : tendsto f' l (ùìù y)) {c : F'} (hc : c ‚â† 0) :
  is_O f' (Œª x, c) l :=
begin
  refine is_O.trans _ (is_O_const_const (‚à•y‚à• + 1) hc l),
  use 1,
  simp only [is_O_with, one_mul],
  have : tendsto (Œªx, ‚à•f' x‚à•) l (ùìù ‚à•y‚à•), from (continuous_norm.tendsto _).comp h,
  have Iy : ‚à•y‚à• < ‚à•‚à•y‚à• + 1‚à•, from lt_of_lt_of_le (lt_add_one _) (le_abs_self _),
  exact this (ge_mem_nhds Iy)
end

section

variable (ùïú)

theorem is_o_one_iff : is_o f' (Œª x, (1 : ùïú)) l ‚Üî tendsto f' l (ùìù 0) :=
is_o_const_iff one_ne_zero

theorem is_O_one_of_tendsto {y : E'} (h : tendsto f' l (ùìù y)) :
  is_O f' (Œª x, (1:ùïú)) l :=
is_O_const_of_tendsto h one_ne_zero

theorem is_O.trans_tendsto_nhds (hfg : is_O f g' l) {y : F'} (hg : tendsto g' l (ùìù y)) :
  is_O f (Œª x, (1:ùïú)) l :=
hfg.trans $ is_O_one_of_tendsto ùïú hg

end

theorem is_O.trans_tendsto (hfg : is_O f' g' l) (hg : tendsto g' l (ùìù 0)) :
  tendsto f' l (ùìù 0) :=
(is_o_one_iff ‚Ñù).1 $ hfg.trans_is_o $ (is_o_one_iff ‚Ñù).2 hg

theorem is_o.trans_tendsto (hfg : is_o f' g' l) (hg : tendsto g' l (ùìù 0)) :
  tendsto f' l (ùìù 0) :=
hfg.is_O.trans_tendsto hg

/-! ### Multiplication by a constant -/

theorem is_O_with_const_mul_self (c : R) (f : Œ± ‚Üí R) (l : filter Œ±) :
  is_O_with ‚à•c‚à• (Œª x, c * f x) f l :=
is_O_with_of_le' _ $ Œª x, norm_mul_le _ _

theorem is_O_const_mul_self (c : R) (f : Œ± ‚Üí R) (l : filter Œ±) :
  is_O (Œª x, c * f x) f l :=
(is_O_with_const_mul_self c f l).is_O

theorem is_O_with.const_mul_left {f : Œ± ‚Üí R} (h : is_O_with c f g l) (c' : R) :
  is_O_with (‚à•c'‚à• * c) (Œª x, c' * f x) g l :=
(is_O_with_const_mul_self c' f l).trans h (norm_nonneg c')

theorem is_O.const_mul_left {f : Œ± ‚Üí R} (h : is_O f g l) (c' : R) :
  is_O (Œª x, c' * f x) g l :=
let ‚ü®c, hc‚ü© := h in (hc.const_mul_left c').is_O

theorem is_O_with_self_const_mul' (u : units R) (f : Œ± ‚Üí R) (l : filter Œ±) :
  is_O_with ‚à•(‚Üëu‚Åª¬π:R)‚à• f (Œª x, ‚Üëu * f x) l :=
(is_O_with_const_mul_self ‚Üëu‚Åª¬π _ l).congr_left $ Œª x, u.inv_mul_cancel_left (f x)

theorem is_O_with_self_const_mul (c : ùïú) (hc : c ‚â† 0) (f : Œ± ‚Üí ùïú) (l : filter Œ±) :
  is_O_with ‚à•c‚à•‚Åª¬π f (Œª x, c * f x) l :=
(is_O_with_self_const_mul' (units.mk0 c hc) f l).congr_const $
  normed_field.norm_inv c

theorem is_O_self_const_mul' {c : R} (hc : is_unit c) (f : Œ± ‚Üí R) (l : filter Œ±) :
  is_O f (Œª x, c * f x) l :=
let ‚ü®u, hu‚ü© := hc in hu ‚ñ∏ (is_O_with_self_const_mul' u f l).is_O

theorem is_O_self_const_mul (c : ùïú) (hc : c ‚â† 0) (f : Œ± ‚Üí ùïú) (l : filter Œ±) :
  is_O f (Œª x, c * f x) l :=
is_O_self_const_mul' (is_unit.mk0 c hc) f l

theorem is_O_const_mul_left_iff' {f : Œ± ‚Üí R} {c : R} (hc : is_unit c) :
  is_O (Œª x, c * f x) g l ‚Üî is_O f g l :=
‚ü®(is_O_self_const_mul' hc f l).trans, Œª h, h.const_mul_left c‚ü©

theorem is_O_const_mul_left_iff {f : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) :
  is_O (Œª x, c * f x) g l ‚Üî is_O f g l :=
is_O_const_mul_left_iff' $ is_unit.mk0 c hc

theorem is_o.const_mul_left {f : Œ± ‚Üí R} (h : is_o f g l) (c : R) :
  is_o (Œª x, c * f x) g l :=
(is_O_const_mul_self c f l).trans_is_o h

theorem is_o_const_mul_left_iff' {f : Œ± ‚Üí R} {c : R} (hc : is_unit c) :
  is_o (Œª x, c * f x) g l ‚Üî is_o f g l :=
‚ü®(is_O_self_const_mul' hc f l).trans_is_o, Œª h, h.const_mul_left c‚ü©

theorem is_o_const_mul_left_iff {f : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) :
  is_o (Œª x, c * f x) g l ‚Üî is_o f g l :=
is_o_const_mul_left_iff' $ is_unit.mk0 c hc

theorem is_O_with.of_const_mul_right {g : Œ± ‚Üí R} {c : R} (hc' : 0 ‚â§ c')
  (h : is_O_with c' f (Œª x, c * g x) l) :
  is_O_with (c' * ‚à•c‚à•) f g l :=
h.trans (is_O_with_const_mul_self c g l) hc'

theorem is_O.of_const_mul_right {g : Œ± ‚Üí R} {c : R}
  (h : is_O f (Œª x, c * g x) l) :
  is_O f g l :=
let ‚ü®c, cnonneg, hc‚ü© := h.exists_nonneg in (hc.of_const_mul_right cnonneg).is_O

theorem is_O_with.const_mul_right' {g : Œ± ‚Üí R} {u : units R} {c' : ‚Ñù} (hc' : 0 ‚â§ c')
  (h : is_O_with c' f g l) :
  is_O_with (c' * ‚à•(‚Üëu‚Åª¬π:R)‚à•) f (Œª x, ‚Üëu * g x) l :=
h.trans (is_O_with_self_const_mul' _ _ _) hc'

theorem is_O_with.const_mul_right {g : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0)
  {c' : ‚Ñù} (hc' : 0 ‚â§ c') (h : is_O_with c' f g l) :
  is_O_with (c' * ‚à•c‚à•‚Åª¬π) f (Œª x, c * g x) l :=
h.trans (is_O_with_self_const_mul c hc g l) hc'

theorem is_O.const_mul_right' {g : Œ± ‚Üí R} {c : R} (hc : is_unit c) (h : is_O f g l) :
  is_O f (Œª x, c * g x) l :=
h.trans (is_O_self_const_mul' hc g l)

theorem is_O.const_mul_right {g : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) (h : is_O f g l) :
  is_O f (Œª x, c * g x) l :=
h.const_mul_right' $ is_unit.mk0 c hc

theorem is_O_const_mul_right_iff' {g : Œ± ‚Üí R} {c : R} (hc : is_unit c) :
  is_O f (Œª x, c * g x) l ‚Üî is_O f g l :=
‚ü®Œª h, h.of_const_mul_right, Œª h, h.const_mul_right' hc‚ü©

theorem is_O_const_mul_right_iff {g : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) :
  is_O f (Œª x, c * g x) l ‚Üî is_O f g l :=
is_O_const_mul_right_iff' $ is_unit.mk0 c hc

theorem is_o.of_const_mul_right {g : Œ± ‚Üí R} {c : R} (h : is_o f (Œª x, c * g x) l) :
  is_o f g l :=
h.trans_is_O (is_O_const_mul_self c g l)

theorem is_o.const_mul_right' {g : Œ± ‚Üí R} {c : R} (hc : is_unit c) (h : is_o f g l) :
  is_o f (Œª x, c * g x) l :=
h.trans_is_O (is_O_self_const_mul' hc g l)

theorem is_o.const_mul_right {g : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) (h : is_o f g l) :
  is_o f (Œª x, c * g x) l :=
h.const_mul_right' $ is_unit.mk0 c hc

theorem is_o_const_mul_right_iff' {g : Œ± ‚Üí R} {c : R} (hc : is_unit c) :
  is_o f (Œª x, c * g x) l ‚Üî is_o f g l :=
‚ü®Œª h, h.of_const_mul_right, Œª h, h.const_mul_right' hc‚ü©

theorem is_o_const_mul_right_iff {g : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) :
  is_o f (Œª x, c * g x) l ‚Üî is_o f g l :=
is_o_const_mul_right_iff' $ is_unit.mk0 c hc

/-! ### Multiplication -/

theorem is_O_with.mul {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí R} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí ùïú} {c‚ÇÅ c‚ÇÇ : ‚Ñù}
  (h‚ÇÅ : is_O_with c‚ÇÅ f‚ÇÅ g‚ÇÅ l) (h‚ÇÇ : is_O_with c‚ÇÇ f‚ÇÇ g‚ÇÇ l) :
  is_O_with (c‚ÇÅ * c‚ÇÇ) (Œª x, f‚ÇÅ x * f‚ÇÇ x) (Œª x, g‚ÇÅ x * g‚ÇÇ x) l :=
begin
  filter_upwards [h‚ÇÅ, h‚ÇÇ], simp only [mem_set_of_eq],
  intros x hx‚ÇÅ hx‚ÇÇ,
  apply le_trans (norm_mul_le _ _),
  convert mul_le_mul hx‚ÇÅ hx‚ÇÇ (norm_nonneg _) (le_trans (norm_nonneg _) hx‚ÇÅ) using 1,
  rw normed_field.norm_mul,
  ac_refl
end

theorem is_O.mul {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí R} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí ùïú}
  (h‚ÇÅ : is_O f‚ÇÅ g‚ÇÅ l) (h‚ÇÇ : is_O f‚ÇÇ g‚ÇÇ l) :
  is_O (Œª x, f‚ÇÅ x * f‚ÇÇ x) (Œª x, g‚ÇÅ x * g‚ÇÇ x) l :=
let ‚ü®c, hc‚ü© := h‚ÇÅ, ‚ü®c', hc'‚ü© := h‚ÇÇ in (hc.mul hc').is_O

theorem is_O.mul_is_o {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí R} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí ùïú}
  (h‚ÇÅ : is_O f‚ÇÅ g‚ÇÅ l) (h‚ÇÇ : is_o f‚ÇÇ g‚ÇÇ l) :
  is_o (Œª x, f‚ÇÅ x * f‚ÇÇ x) (Œª x, g‚ÇÅ x * g‚ÇÇ x) l :=
begin
  intros c cpos,
  rcases h‚ÇÅ.exists_pos with ‚ü®c', c'pos, hc'‚ü©,
  exact (hc'.mul (h‚ÇÇ (div_pos cpos c'pos))).congr_const (mul_div_cancel' _ (ne_of_gt c'pos))
end

theorem is_o.mul_is_O {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí R} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí ùïú}
  (h‚ÇÅ : is_o f‚ÇÅ g‚ÇÅ l) (h‚ÇÇ : is_O f‚ÇÇ g‚ÇÇ l) :
  is_o (Œª x, f‚ÇÅ x * f‚ÇÇ x) (Œª x, g‚ÇÅ x * g‚ÇÇ x) l :=
begin
  intros c cpos,
  rcases h‚ÇÇ.exists_pos with ‚ü®c', c'pos, hc'‚ü©,
  exact ((h‚ÇÅ (div_pos cpos c'pos)).mul hc').congr_const (div_mul_cancel _ (ne_of_gt c'pos))
end

theorem is_o.mul {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí R} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí ùïú} (h‚ÇÅ : is_o f‚ÇÅ g‚ÇÅ l) (h‚ÇÇ : is_o f‚ÇÇ g‚ÇÇ l) :
  is_o (Œª x, f‚ÇÅ x * f‚ÇÇ x) (Œª x, g‚ÇÅ x * g‚ÇÇ x) l :=
h‚ÇÅ.mul_is_O h‚ÇÇ.is_O

/-! ### Scalar multiplication -/

section smul_const
variables [normed_space ùïú E']

theorem is_O_with.const_smul_left (h : is_O_with c f' g l) (c' : ùïú) :
  is_O_with (‚à•c'‚à• * c) (Œª x, c' ‚Ä¢ f' x) g l :=
by refine ((h.norm_left.const_mul_left (‚à•c'‚à•)).congr _ _ (Œª _, rfl)).of_norm_left;
    intros; simp only [norm_norm, norm_smul]

theorem is_O_const_smul_left_iff {c : ùïú} (hc : c ‚â† 0) :
  is_O (Œª x, c ‚Ä¢ f' x) g l ‚Üî is_O f' g l :=
begin
  have cne0 : ‚à•c‚à• ‚â† 0, from mt norm_eq_zero.mp hc,
  rw [‚Üêis_O_norm_left], simp only [norm_smul],
  rw [is_O_const_mul_left_iff cne0, is_O_norm_left],
end

theorem is_o_const_smul_left (h : is_o f' g l) (c : ùïú) :
  is_o (Œª x, c ‚Ä¢ f' x) g l :=
begin
  refine ((h.norm_left.const_mul_left (‚à•c‚à•)).congr_left _).of_norm_left,
  exact Œª x, (norm_smul _ _).symm
end

theorem is_o_const_smul_left_iff {c : ùïú} (hc : c ‚â† 0) :
  is_o (Œª x, c ‚Ä¢ f' x) g l ‚Üî is_o f' g l :=
begin
  have cne0 : ‚à•c‚à• ‚â† 0, from mt norm_eq_zero.mp hc,
  rw [‚Üêis_o_norm_left], simp only [norm_smul],
  rw [is_o_const_mul_left_iff cne0, is_o_norm_left]
end

theorem is_O_const_smul_right {c : ùïú} (hc : c ‚â† 0) :
  is_O f (Œª x, c ‚Ä¢ f' x) l ‚Üî is_O f f' l :=
begin
  have cne0 : ‚à•c‚à• ‚â† 0, from mt norm_eq_zero.mp hc,
  rw [‚Üêis_O_norm_right], simp only [norm_smul],
  rw [is_O_const_mul_right_iff cne0, is_O_norm_right]
end

theorem is_o_const_smul_right {c : ùïú} (hc : c ‚â† 0) :
  is_o f (Œª x, c ‚Ä¢ f' x) l ‚Üî is_o f f' l :=
begin
  have cne0 : ‚à•c‚à• ‚â† 0, from mt norm_eq_zero.mp hc,
  rw [‚Üêis_o_norm_right], simp only [norm_smul],
  rw [is_o_const_mul_right_iff cne0, is_o_norm_right]
end

end smul_const

section smul

variables [normed_space ùïú E'] [normed_space ùïú F']

theorem is_O_with.smul {k‚ÇÅ k‚ÇÇ : Œ± ‚Üí ùïú} (h‚ÇÅ : is_O_with c k‚ÇÅ k‚ÇÇ l) (h‚ÇÇ : is_O_with c' f' g' l) :
  is_O_with (c * c') (Œª x, k‚ÇÅ x ‚Ä¢ f' x) (Œª x, k‚ÇÇ x ‚Ä¢ g' x) l :=
by refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr rfl _ _).of_norm_norm;
  by intros; simp only [norm_smul]

theorem is_O.smul {k‚ÇÅ k‚ÇÇ : Œ± ‚Üí ùïú} (h‚ÇÅ : is_O k‚ÇÅ k‚ÇÇ l) (h‚ÇÇ : is_O f' g' l) :
  is_O (Œª x, k‚ÇÅ x ‚Ä¢ f' x) (Œª x, k‚ÇÇ x ‚Ä¢ g' x) l :=
by refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr _ _).of_norm_norm;
  by intros; simp only [norm_smul]

theorem is_O.smul_is_o {k‚ÇÅ k‚ÇÇ : Œ± ‚Üí ùïú} (h‚ÇÅ : is_O k‚ÇÅ k‚ÇÇ l) (h‚ÇÇ : is_o f' g' l) :
  is_o (Œª x, k‚ÇÅ x ‚Ä¢ f' x) (Œª x, k‚ÇÇ x ‚Ä¢ g' x) l :=
by refine ((h‚ÇÅ.norm_norm.mul_is_o h‚ÇÇ.norm_norm).congr _ _).of_norm_norm;
  by intros; simp only [norm_smul]

theorem is_o.smul_is_O {k‚ÇÅ k‚ÇÇ : Œ± ‚Üí ùïú} (h‚ÇÅ : is_o k‚ÇÅ k‚ÇÇ l) (h‚ÇÇ : is_O f' g' l) :
  is_o (Œª x, k‚ÇÅ x ‚Ä¢ f' x) (Œª x, k‚ÇÇ x ‚Ä¢ g' x) l :=
by refine ((h‚ÇÅ.norm_norm.mul_is_O h‚ÇÇ.norm_norm).congr _ _).of_norm_norm;
  by intros; simp only [norm_smul]

theorem is_o.smul {k‚ÇÅ k‚ÇÇ : Œ± ‚Üí ùïú} (h‚ÇÅ : is_o k‚ÇÅ k‚ÇÇ l) (h‚ÇÇ : is_o f' g' l) :
  is_o (Œª x, k‚ÇÅ x ‚Ä¢ f' x) (Œª x, k‚ÇÇ x ‚Ä¢ g' x) l :=
by refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr _ _).of_norm_norm;
  by intros; simp only [norm_smul]

end smul

/-! ### Sum -/

section sum

variables {Œπ : Type*} {A : Œπ ‚Üí Œ± ‚Üí E'} {C : Œπ ‚Üí ‚Ñù} {s : finset Œπ}

theorem is_O_with.sum (h : ‚àÄ i ‚àà s, is_O_with (C i) (A i) g l) :
  is_O_with (‚àë i in s, C i) (Œª x, ‚àë i in s, A i x) g l :=
begin
  induction s using finset.induction_on with i s is IH,
  { simp only [is_O_with_zero', finset.sum_empty, forall_true_iff] },
  { simp only [is, finset.sum_insert, not_false_iff],
    exact (h _ (finset.mem_insert_self i s)).add (IH (Œª j hj, h _ (finset.mem_insert_of_mem hj))) }
end

theorem is_O.sum (h : ‚àÄ i ‚àà s, is_O (A i) g l) :
  is_O (Œª x, ‚àë i in s, A i x) g l :=
begin
  induction s using finset.induction_on with i s is IH,
  { simp only [is_O_zero, finset.sum_empty, forall_true_iff] },
  { simp only [is, finset.sum_insert, not_false_iff],
    exact (h _ (finset.mem_insert_self i s)).add (IH (Œª j hj, h _ (finset.mem_insert_of_mem hj))) }
end

theorem is_o.sum (h : ‚àÄ i ‚àà s, is_o (A i) g' l) :
  is_o (Œª x, ‚àë i in s, A i x) g' l :=
begin
  induction s using finset.induction_on with i s is IH,
  { simp only [is_o_zero, finset.sum_empty, forall_true_iff] },
  { simp only [is, finset.sum_insert, not_false_iff],
    exact (h _ (finset.mem_insert_self i s)).add (IH (Œª j hj, h _ (finset.mem_insert_of_mem hj))) }
end

end sum

/-! ### Relation between `f = o(g)` and `f / g ‚Üí 0` -/

theorem is_o.tendsto_0 {f g : Œ± ‚Üí ùïú} {l : filter Œ±} (h : is_o f g l) :
  tendsto (Œª x, f x / (g x)) l (ùìù 0) :=
have eq‚ÇÅ : is_o (Œª x, f x / g x) (Œª x, g x / g x) l,
  from h.mul_is_O (is_O_refl _ _),
have eq‚ÇÇ : is_O (Œª x, g x / g x) (Œª x, (1 : ùïú)) l,
  from is_O_of_le _ (Œª x, by by_cases h : ‚à•g x‚à• = 0; simp [h, zero_le_one]),
(is_o_one_iff ùïú).mp (eq‚ÇÅ.trans_is_O eq‚ÇÇ)

private theorem is_o_of_tendsto {f g : Œ± ‚Üí ùïú} {l : filter Œ±}
    (hgf : ‚àÄ x, g x = 0 ‚Üí f x = 0) (h : tendsto (Œª x, f x / (g x)) l (ùìù 0)) :
  is_o f g l :=
have eq‚ÇÅ : is_o (Œª x, f x / (g x)) (Œª x, (1 : ùïú)) l,
  from (is_o_one_iff _).mpr h,
have eq‚ÇÇ : is_o (Œª x, f x / g x * g x) g l,
  by convert eq‚ÇÅ.mul_is_O (is_O_refl _ _); simp,
have eq‚ÇÉ : is_O f (Œª x, f x / g x * g x) l,
  begin
    refine is_O_of_le _ (Œª x, _),
    by_cases H : g x = 0,
    { simp only [H, hgf _ H, mul_zero] },
    { simp only [div_mul_cancel _ H] }
  end,
eq‚ÇÉ.trans_is_o eq‚ÇÇ

theorem is_o_iff_tendsto {f g : Œ± ‚Üí ùïú} {l : filter Œ±}
    (hgf : ‚àÄ x, g x = 0 ‚Üí f x = 0) :
  is_o f g l ‚Üî tendsto (Œª x, f x / (g x)) l (ùìù 0) :=
iff.intro is_o.tendsto_0 (is_o_of_tendsto hgf)

/-! ### Miscellanous lemmas -/

theorem is_o_pow_pow {m n : ‚Ñï} (h : m < n) :
  is_o (Œª(x : ùïú), x^n) (Œªx, x^m) (ùìù 0) :=
begin
  let p := n - m,
  have nmp : n = m + p := (nat.add_sub_cancel' (le_of_lt h)).symm,
  have : (Œª(x : ùïú), x^m) = (Œªx, x^m * 1), by simp only [mul_one],
  simp only [this, pow_add, nmp],
  refine is_O.mul_is_o (is_O_refl _ _) ((is_o_one_iff _).2 _),
  convert (continuous_pow p).tendsto (0 : ùïú),
  exact (zero_pow (nat.sub_pos_of_lt h)).symm
end

theorem is_o_pow_id {n : ‚Ñï} (h : 1 < n) :
  is_o (Œª(x : ùïú), x^n) (Œªx, x) (ùìù 0) :=
by { convert is_o_pow_pow h, simp only [pow_one] }

theorem is_O_with.right_le_sub_of_lt_1 {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E'} (h : is_O_with c f‚ÇÅ f‚ÇÇ l) (hc : c < 1) :
  is_O_with (1 / (1 - c)) f‚ÇÇ (Œªx, f‚ÇÇ x - f‚ÇÅ x) l :=
mem_sets_of_superset h $ Œª x hx,
begin
  simp only [mem_set_of_eq] at hx ‚ä¢,
  rw [mul_comm, one_div_eq_inv, ‚Üê div_eq_mul_inv, le_div_iff, mul_sub, mul_one, mul_comm],
  { exact le_trans (sub_le_sub_left hx _) (norm_sub_norm_le _ _) },
  { exact sub_pos.2 hc }
end

theorem is_O_with.right_le_add_of_lt_1 {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E'} (h : is_O_with c f‚ÇÅ f‚ÇÇ l) (hc : c < 1) :
  is_O_with (1 / (1 - c)) f‚ÇÇ (Œªx, f‚ÇÅ x + f‚ÇÇ x) l :=
(h.neg_right.right_le_sub_of_lt_1 hc).neg_right.of_neg_left.congr rfl (Œª x, rfl)
  (Œª x, by rw [neg_sub, sub_neg_eq_add])

theorem is_o.right_is_O_sub {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E'} (h : is_o f‚ÇÅ f‚ÇÇ l) :
  is_O f‚ÇÇ (Œªx, f‚ÇÇ x - f‚ÇÅ x) l :=
((h.def' one_half_pos).right_le_sub_of_lt_1 one_half_lt_one).is_O

theorem is_o.right_is_O_add {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E'} (h : is_o f‚ÇÅ f‚ÇÇ l) :
  is_O f‚ÇÇ (Œªx, f‚ÇÅ x + f‚ÇÇ x) l :=
((h.def' one_half_pos).right_le_add_of_lt_1 one_half_lt_one).is_O

end asymptotics

namespace local_homeomorph

variables {Œ± : Type*} {Œ≤ : Type*} [topological_space Œ±] [topological_space Œ≤]

variables {E : Type*} [has_norm E] {F : Type*} [has_norm F]

open asymptotics

/-- Transfer `is_O_with` over a `local_homeomorph`. -/
lemma is_O_with_congr (e : local_homeomorph Œ± Œ≤) {b : Œ≤} (hb : b ‚àà e.target)
  {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} {C : ‚Ñù} :
  is_O_with C f g (ùìù b) ‚Üî is_O_with C (f ‚àò e) (g ‚àò e) (ùìù (e.symm b)) :=
‚ü®Œª h, h.comp_tendsto $
  by { convert e.continuous_at (e.map_target hb), exact (e.right_inv hb).symm },
  Œª h, (h.comp_tendsto (e.continuous_at_symm hb)).congr' rfl
    ((e.eventually_right_inverse hb).mono $ Œª x hx, congr_arg f hx)
    ((e.eventually_right_inverse hb).mono $ Œª x hx, congr_arg g hx)‚ü©

/-- Transfer `is_O` over a `local_homeomorph`. -/
lemma is_O_congr (e : local_homeomorph Œ± Œ≤) {b : Œ≤} (hb : b ‚àà e.target) {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} :
  is_O f g (ùìù b) ‚Üî is_O (f ‚àò e) (g ‚àò e) (ùìù (e.symm b)) :=
exists_congr $ Œª C, e.is_O_with_congr hb

/-- Transfer `is_o` over a `local_homeomorph`. -/
lemma is_o_congr (e : local_homeomorph Œ± Œ≤) {b : Œ≤} (hb : b ‚àà e.target) {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} :
  is_o f g (ùìù b) ‚Üî is_o (f ‚àò e) (g ‚àò e) (ùìù (e.symm b)) :=
forall_congr $ Œª c, forall_congr $ Œª hc, e.is_O_with_congr hb

end local_homeomorph

namespace homeomorph

variables {Œ± : Type*} {Œ≤ : Type*} [topological_space Œ±] [topological_space Œ≤]

variables {E : Type*} [has_norm E] {F : Type*} [has_norm F]

open asymptotics

/-- Transfer `is_O_with` over a `homeomorph`. -/
lemma is_O_with_congr (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} {C : ‚Ñù} :
  is_O_with C f g (ùìù b) ‚Üî is_O_with C (f ‚àò e) (g ‚àò e) (ùìù (e.symm b)) :=
e.to_local_homeomorph.is_O_with_congr trivial

/-- Transfer `is_O` over a `homeomorph`. -/
lemma is_O_congr (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} :
  is_O f g (ùìù b) ‚Üî is_O (f ‚àò e) (g ‚àò e) (ùìù (e.symm b)) :=
exists_congr $ Œª C, e.is_O_with_congr

/-- Transfer `is_o` over a `homeomorph`. -/
lemma is_o_congr (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} :
  is_o f g (ùìù b) ‚Üî is_o (f ‚àò e) (g ‚àò e) (ùìù (e.symm b)) :=
forall_congr $ Œª c, forall_congr $ Œª hc, e.is_O_with_congr

end homeomorph

attribute [irreducible] asymptotics.is_o asymptotics.is_O asymptotics.is_O_with
