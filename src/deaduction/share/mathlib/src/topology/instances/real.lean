/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro

The real numbers ‚Ñù.

They are constructed as the topological completion of ‚Ñö. With the following steps:
(1) prove that ‚Ñö forms a uniform space.
(2) subtraction and addition are uniform continuous functions in this space
(3) for multiplication and inverse this only holds on bounded subsets
(4) ‚Ñù is defined as separated Cauchy filters over ‚Ñö (the separation requires a quotient construction)
(5) extend the uniform continuous functions along the completion
(6) proof field properties using the principle of extension of identities

TODO

generalizations:
* topological groups & rings
* order topologies
* Archimedean fields

-/
import topology.metric_space.basic
import topology.algebra.uniform_group
import topology.algebra.ring

noncomputable theory
open classical set filter topological_space metric
open_locale classical
open_locale topological_space

universes u v w
variables {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}

instance : metric_space ‚Ñö :=
metric_space.induced coe rat.cast_injective real.metric_space

theorem rat.dist_eq (x y : ‚Ñö) : dist x y = abs (x - y) := rfl

@[norm_cast, simp] lemma rat.dist_cast (x y : ‚Ñö) : dist (x : ‚Ñù) y = dist x y := rfl

section low_prio
-- we want to ignore this instance for the next declaration
local attribute [instance, priority 10] int.uniform_space
instance : metric_space ‚Ñ§ :=
begin
  letI M := metric_space.induced coe int.cast_injective real.metric_space,
  refine @metric_space.replace_uniformity _ int.uniform_space M
    (le_antisymm refl_le_uniformity $ Œª r ru,
      mem_uniformity_dist.2 ‚ü®1, zero_lt_one, Œª a b h,
      mem_principal_sets.1 ru $ dist_le_zero.1 (_ : (abs (a - b) : ‚Ñù) ‚â§ 0)‚ü©),
  have : (abs (‚Üëa - ‚Üëb) : ‚Ñù) < 1 := h,
  have : abs (a - b) < 1, by norm_cast at this; assumption,
  have : abs (a - b) ‚â§ 0 := (@int.lt_add_one_iff _ 0).mp this,
  norm_cast, assumption
end
end low_prio

theorem int.dist_eq (x y : ‚Ñ§) : dist x y = abs (x - y) := rfl

@[norm_cast, simp] theorem int.dist_cast_real (x y : ‚Ñ§) : dist (x : ‚Ñù) y = dist x y := rfl

@[norm_cast, simp] theorem int.dist_cast_rat (x y : ‚Ñ§) : dist (x : ‚Ñö) y = dist x y :=
by rw [‚Üê int.dist_cast_real, ‚Üê rat.dist_cast]; congr' 1; norm_cast

theorem uniform_continuous_of_rat : uniform_continuous (coe : ‚Ñö ‚Üí ‚Ñù) :=
uniform_continuous_comap

theorem uniform_embedding_of_rat : uniform_embedding (coe : ‚Ñö ‚Üí ‚Ñù) :=
uniform_embedding_comap rat.cast_injective

theorem dense_embedding_of_rat : dense_embedding (coe : ‚Ñö ‚Üí ‚Ñù) :=
uniform_embedding_of_rat.dense_embedding $
Œª x, mem_closure_iff_nhds.2 $ Œª t ht,
let ‚ü®Œµ,Œµ0, hŒµ‚ü© := mem_nhds_iff.1 ht in
let ‚ü®q, h‚ü© := exists_rat_near x Œµ0 in
‚ü®_, hŒµ (mem_ball'.2 h), q, rfl‚ü©

theorem embedding_of_rat : embedding (coe : ‚Ñö ‚Üí ‚Ñù) := dense_embedding_of_rat.to_embedding

theorem continuous_of_rat : continuous (coe : ‚Ñö ‚Üí ‚Ñù) := uniform_continuous_of_rat.continuous

theorem real.uniform_continuous_add : uniform_continuous (Œªp : ‚Ñù √ó ‚Ñù, p.1 + p.2) :=
metric.uniform_continuous_iff.2 $ Œª Œµ Œµ0,
let ‚ü®Œ¥, Œ¥0, HŒ¥‚ü© := rat_add_continuous_lemma abs Œµ0 in
‚ü®Œ¥, Œ¥0, Œª a b h, let ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := max_lt_iff.1 h in HŒ¥ h‚ÇÅ h‚ÇÇ‚ü©

-- TODO(Mario): Find a way to use rat_add_continuous_lemma
theorem rat.uniform_continuous_add : uniform_continuous (Œªp : ‚Ñö √ó ‚Ñö, p.1 + p.2) :=
uniform_embedding_of_rat.to_uniform_inducing.uniform_continuous_iff.2 $ by simp [(‚àò)]; exact
real.uniform_continuous_add.comp ((uniform_continuous_of_rat.comp uniform_continuous_fst).prod_mk
  (uniform_continuous_of_rat.comp uniform_continuous_snd))

theorem real.uniform_continuous_neg : uniform_continuous (@has_neg.neg ‚Ñù _) :=
metric.uniform_continuous_iff.2 $ Œª Œµ Œµ0, ‚ü®_, Œµ0, Œª a b h,
  by rw dist_comm at h; simpa [real.dist_eq] using h‚ü©

theorem rat.uniform_continuous_neg : uniform_continuous (@has_neg.neg ‚Ñö _) :=
metric.uniform_continuous_iff.2 $ Œª Œµ Œµ0, ‚ü®_, Œµ0, Œª a b h,
  by rw dist_comm at h; simpa [rat.dist_eq] using h‚ü©

instance : uniform_add_group ‚Ñù :=
uniform_add_group.mk' real.uniform_continuous_add real.uniform_continuous_neg

instance : uniform_add_group ‚Ñö :=
uniform_add_group.mk' rat.uniform_continuous_add rat.uniform_continuous_neg

 -- short-circuit type class inference
instance : topological_add_group ‚Ñù := by apply_instance
instance : topological_add_group ‚Ñö := by apply_instance

instance : order_topology ‚Ñö :=
induced_order_topology _ (Œª x y, rat.cast_lt) (@exists_rat_btwn _ _ _)

lemma real.is_topological_basis_Ioo_rat :
  @is_topological_basis ‚Ñù _ (‚ãÉ(a b : ‚Ñö) (h : a < b), {Ioo a b}) :=
is_topological_basis_of_open_of_nhds
  (by simp [is_open_Ioo] {contextual:=tt})
  (assume a v hav hv,
    let ‚ü®l, u, hl, hu, h‚ü© := (mem_nhds_unbounded (no_top _) (no_bot _)).mp (mem_nhds_sets hv hav),
        ‚ü®q, hlq, hqa‚ü© := exists_rat_btwn hl,
        ‚ü®p, hap, hpu‚ü© := exists_rat_btwn hu in
    ‚ü®Ioo q p,
      by simp; exact ‚ü®q, p, rat.cast_lt.1 $ lt_trans hqa hap, rfl‚ü©,
      ‚ü®hqa, hap‚ü©, assume a' ‚ü®hqa', ha'p‚ü©, h _ (lt_trans hlq hqa') (lt_trans ha'p hpu)‚ü©)

instance : second_countable_topology ‚Ñù :=
‚ü®‚ü®(‚ãÉ(a b : ‚Ñö) (h : a < b), {Ioo a b}),
  by simp [countable_Union, countable_Union_Prop],
  real.is_topological_basis_Ioo_rat.2.2‚ü©‚ü©

/- TODO(Mario): Prove that these are uniform isomorphisms instead of uniform embeddings
lemma uniform_embedding_add_rat {r : ‚Ñö} : uniform_embedding (Œªp:‚Ñö, p + r) :=
_

lemma uniform_embedding_mul_rat {q : ‚Ñö} (hq : q ‚â† 0) : uniform_embedding ((*) q) :=
_ -/

lemma real.uniform_continuous_inv (s : set ‚Ñù) {r : ‚Ñù} (r0 : 0 < r) (H : ‚àÄ x ‚àà s, r ‚â§ abs x) :
  uniform_continuous (Œªp:s, p.1‚Åª¬π) :=
metric.uniform_continuous_iff.2 $ Œª Œµ Œµ0,
let ‚ü®Œ¥, Œ¥0, HŒ¥‚ü© := rat_inv_continuous_lemma abs Œµ0 r0 in
‚ü®Œ¥, Œ¥0, Œª a b h, HŒ¥ (H _ a.2) (H _ b.2) h‚ü©

lemma real.uniform_continuous_abs : uniform_continuous (abs : ‚Ñù ‚Üí ‚Ñù) :=
metric.uniform_continuous_iff.2 $ Œª Œµ Œµ0,
  ‚ü®Œµ, Œµ0, Œª a b, lt_of_le_of_lt (abs_abs_sub_abs_le_abs_sub _ _)‚ü©

lemma real.continuous_abs : continuous (abs : ‚Ñù ‚Üí ‚Ñù) :=
real.uniform_continuous_abs.continuous

lemma rat.uniform_continuous_abs : uniform_continuous (abs : ‚Ñö ‚Üí ‚Ñö) :=
metric.uniform_continuous_iff.2 $ Œª Œµ Œµ0,
  ‚ü®Œµ, Œµ0, Œª a b h, lt_of_le_of_lt
    (by simpa [rat.dist_eq] using abs_abs_sub_abs_le_abs_sub _ _) h‚ü©

lemma rat.continuous_abs : continuous (abs : ‚Ñö ‚Üí ‚Ñö) :=
rat.uniform_continuous_abs.continuous

lemma real.tendsto_inv {r : ‚Ñù} (r0 : r ‚â† 0) : tendsto (Œªq, q‚Åª¬π) (ùìù r) (ùìù r‚Åª¬π) :=
by rw ‚Üê abs_pos_iff at r0; exact
tendsto_of_uniform_continuous_subtype
  (real.uniform_continuous_inv {x | abs r / 2 < abs x} (half_pos r0) (Œª x h, le_of_lt h))
  (mem_nhds_sets (real.continuous_abs _ $ is_open_lt' (abs r / 2)) (half_lt_self r0))

lemma real.continuous_inv : continuous (Œªa:{r:‚Ñù // r ‚â† 0}, a.val‚Åª¬π) :=
continuous_iff_continuous_at.mpr $ assume ‚ü®r, hr‚ü©,
  tendsto.comp (real.tendsto_inv hr) (continuous_iff_continuous_at.mp continuous_subtype_val _)

lemma real.continuous.inv [topological_space Œ±] {f : Œ± ‚Üí ‚Ñù} (h : ‚àÄa, f a ‚â† 0) (hf : continuous f) :
  continuous (Œªa, (f a)‚Åª¬π) :=
show continuous ((has_inv.inv ‚àò @subtype.val ‚Ñù (Œªr, r ‚â† 0)) ‚àò Œªa, ‚ü®f a, h a‚ü©),
  from real.continuous_inv.comp (continuous_subtype_mk _ hf)

lemma real.uniform_continuous_mul_const {x : ‚Ñù} : uniform_continuous ((*) x) :=
metric.uniform_continuous_iff.2 $ Œª Œµ Œµ0, begin
  cases no_top (abs x) with y xy,
  have y0 := lt_of_le_of_lt (abs_nonneg _) xy,
  refine ‚ü®_, div_pos Œµ0 y0, Œª a b h, _‚ü©,
  rw [real.dist_eq, ‚Üê mul_sub, abs_mul, ‚Üê mul_div_cancel' Œµ (ne_of_gt y0)],
  exact mul_lt_mul' (le_of_lt xy) h (abs_nonneg _) y0
end

lemma real.uniform_continuous_mul (s : set (‚Ñù √ó ‚Ñù))
  {r‚ÇÅ r‚ÇÇ : ‚Ñù} (H : ‚àÄ x ‚àà s, abs (x : ‚Ñù √ó ‚Ñù).1 < r‚ÇÅ ‚àß abs x.2 < r‚ÇÇ) :
  uniform_continuous (Œªp:s, p.1.1 * p.1.2) :=
metric.uniform_continuous_iff.2 $ Œª Œµ Œµ0,
let ‚ü®Œ¥, Œ¥0, HŒ¥‚ü© := rat_mul_continuous_lemma abs Œµ0 in
‚ü®Œ¥, Œ¥0, Œª a b h,
  let ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := max_lt_iff.1 h in HŒ¥ (H _ a.2).1 (H _ b.2).2 h‚ÇÅ h‚ÇÇ‚ü©

protected lemma real.continuous_mul : continuous (Œªp : ‚Ñù √ó ‚Ñù, p.1 * p.2) :=
continuous_iff_continuous_at.2 $ Œª ‚ü®a‚ÇÅ, a‚ÇÇ‚ü©,
tendsto_of_uniform_continuous_subtype
  (real.uniform_continuous_mul
    ({x | abs x < abs a‚ÇÅ + 1}.prod {x | abs x < abs a‚ÇÇ + 1})
    (Œª x, id))
  (mem_nhds_sets
    (is_open_prod
      (real.continuous_abs _ $ is_open_gt' (abs a‚ÇÅ + 1))
      (real.continuous_abs _ $ is_open_gt' (abs a‚ÇÇ + 1)))
    ‚ü®lt_add_one (abs a‚ÇÅ), lt_add_one (abs a‚ÇÇ)‚ü©)

instance : topological_ring ‚Ñù :=
{ continuous_mul := real.continuous_mul, ..real.topological_add_group }

instance : topological_semiring ‚Ñù := by apply_instance  -- short-circuit type class inference

lemma rat.continuous_mul : continuous (Œªp : ‚Ñö √ó ‚Ñö, p.1 * p.2) :=
embedding_of_rat.continuous_iff.2 $ by simp [(‚àò)]; exact
real.continuous_mul.comp ((continuous_of_rat.comp continuous_fst).prod_mk
  (continuous_of_rat.comp continuous_snd))

instance : topological_ring ‚Ñö :=
{ continuous_mul := rat.continuous_mul, ..rat.topological_add_group }

theorem real.ball_eq_Ioo (x Œµ : ‚Ñù) : ball x Œµ = Ioo (x - Œµ) (x + Œµ) :=
set.ext $ Œª y, by rw [mem_ball, real.dist_eq,
  abs_sub_lt_iff, sub_lt_iff_lt_add', and_comm, sub_lt]; refl

theorem real.Ioo_eq_ball (x y : ‚Ñù) : Ioo x y = ball ((x + y) / 2) ((y - x) / 2) :=
by rw [real.ball_eq_Ioo, ‚Üê sub_div, add_comm, ‚Üê sub_add,
  add_sub_cancel', add_self_div_two, ‚Üê add_div,
  add_assoc, add_sub_cancel'_right, add_self_div_two]

lemma real.totally_bounded_Ioo (a b : ‚Ñù) : totally_bounded (Ioo a b) :=
metric.totally_bounded_iff.2 $ Œª Œµ Œµ0, begin
  rcases exists_nat_gt ((b - a) / Œµ) with ‚ü®n, ba‚ü©,
  rw [div_lt_iff' Œµ0, sub_lt_iff_lt_add'] at ba,
  let s := (Œª i:‚Ñï, a + Œµ * i) '' {i:‚Ñï | i < n},
  refine ‚ü®s, (set.finite_lt_nat _).image _, _‚ü©,
  rintro x ‚ü®ax, xb‚ü©,
  let i : ‚Ñï := ‚åä(x - a) / Œµ‚åã.to_nat,
  have : (i : ‚Ñ§) = ‚åä(x - a) / Œµ‚åã :=
    int.to_nat_of_nonneg (floor_nonneg.2 $ le_of_lt (div_pos (sub_pos.2 ax) Œµ0)),
  simp, use i, split,
  { rw [‚Üê int.coe_nat_lt, this],
    refine int.cast_lt.1 (lt_of_le_of_lt (floor_le _) _),
    rw [int.cast_coe_nat, div_lt_iff' Œµ0, sub_lt_iff_lt_add'],
    exact lt_trans xb ba },
  { rw [real.dist_eq, ‚Üê int.cast_coe_nat, this, abs_of_nonneg,
        ‚Üê sub_sub, sub_lt_iff_lt_add'],
    { have := lt_floor_add_one ((x - a) / Œµ),
      rwa [div_lt_iff' Œµ0, mul_add, mul_one] at this },
    { have := floor_le ((x - a) / Œµ),
      rwa [sub_nonneg, ‚Üê le_sub_iff_add_le', ‚Üê le_div_iff' Œµ0] } }
end

lemma real.totally_bounded_ball (x Œµ : ‚Ñù) : totally_bounded (ball x Œµ) :=
by rw real.ball_eq_Ioo; apply real.totally_bounded_Ioo

lemma real.totally_bounded_Ico (a b : ‚Ñù) : totally_bounded (Ico a b) :=
let ‚ü®c, ac‚ü© := no_bot a in totally_bounded_subset
  (by exact Œª x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, ‚ü®lt_of_lt_of_le ac h‚ÇÅ, h‚ÇÇ‚ü©)
  (real.totally_bounded_Ioo c b)

lemma real.totally_bounded_Icc (a b : ‚Ñù) : totally_bounded (Icc a b) :=
let ‚ü®c, bc‚ü© := no_top b in totally_bounded_subset
  (by exact Œª x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, ‚ü®h‚ÇÅ, lt_of_le_of_lt h‚ÇÇ bc‚ü©)
  (real.totally_bounded_Ico a c)

lemma rat.totally_bounded_Icc (a b : ‚Ñö) : totally_bounded (Icc a b) :=
begin
  have := totally_bounded_preimage uniform_embedding_of_rat (real.totally_bounded_Icc a b),
  rwa (set.ext (Œª q, _) : Icc _ _ = _), simp
end

instance : complete_space ‚Ñù :=
begin
  apply complete_of_cauchy_seq_tendsto,
  intros u hu,
  let c : cau_seq ‚Ñù abs := ‚ü®u, cauchy_seq_iff'.1 hu‚ü©,
  refine ‚ü®c.lim, Œª s h, _‚ü©,
  rcases metric.mem_nhds_iff.1 h with ‚ü®Œµ, Œµ0, hŒµ‚ü©,
  have := c.equiv_lim Œµ Œµ0,
  simp only [mem_map, mem_at_top_sets, mem_set_of_eq],
  refine this.imp (Œª N hN n hn, hŒµ (hN n hn))
end

lemma tendsto_coe_nat_real_at_top_iff {f : Œ± ‚Üí ‚Ñï} {l : filter Œ±} :
  tendsto (Œª n, (f n : ‚Ñù)) l at_top ‚Üî tendsto f l at_top :=
tendsto_at_top_embedding (assume a‚ÇÅ a‚ÇÇ, nat.cast_le) $
  assume r, let ‚ü®n, hn‚ü© := exists_nat_gt r in ‚ü®n, le_of_lt hn‚ü©

lemma tendsto_coe_nat_real_at_top_at_top : tendsto (coe : ‚Ñï ‚Üí ‚Ñù) at_top at_top :=
tendsto_coe_nat_real_at_top_iff.2 tendsto_id

lemma tendsto_coe_int_real_at_top_iff {f : Œ± ‚Üí ‚Ñ§} {l : filter Œ±} :
  tendsto (Œª n, (f n : ‚Ñù)) l at_top ‚Üî tendsto f l at_top :=
tendsto_at_top_embedding (assume a‚ÇÅ a‚ÇÇ, int.cast_le) $
  assume r, let ‚ü®n, hn‚ü© := exists_nat_gt r in
  ‚ü®(n:‚Ñ§), le_of_lt $ by rwa [int.cast_coe_nat]‚ü©

lemma tendsto_coe_int_real_at_top_at_top : tendsto (coe : ‚Ñ§ ‚Üí ‚Ñù) at_top at_top :=
tendsto_coe_int_real_at_top_iff.2 tendsto_id

section

lemma closure_of_rat_image_lt {q : ‚Ñö} : closure ((coe:‚Ñö ‚Üí ‚Ñù) '' {x | q < x}) = {r | ‚Üëq ‚â§ r} :=
subset.antisymm
  ((closure_subset_iff_subset_of_is_closed (is_closed_ge' _)).2
    (image_subset_iff.2 $ Œª p h, le_of_lt $ (@rat.cast_lt ‚Ñù _ _ _).2 h)) $
Œª x hx, mem_closure_iff_nhds.2 $ Œª t ht,
let ‚ü®Œµ, Œµ0, hŒµ‚ü© := metric.mem_nhds_iff.1 ht in
let ‚ü®p, h‚ÇÅ, h‚ÇÇ‚ü© := exists_rat_btwn ((lt_add_iff_pos_right x).2 Œµ0) in
‚ü®_, hŒµ (show abs _ < _,
    by rwa [abs_of_nonneg (le_of_lt $ sub_pos.2 h‚ÇÅ), sub_lt_iff_lt_add']),
  p, rat.cast_lt.1 (@lt_of_le_of_lt ‚Ñù _ _ _ _ hx h‚ÇÅ), rfl‚ü©

/- TODO(Mario): Put these back only if needed later
lemma closure_of_rat_image_le_eq {q : ‚Ñö} : closure ((coe:‚Ñö ‚Üí ‚Ñù) '' {x | q ‚â§ x}) = {r | ‚Üëq ‚â§ r} :=
_

lemma closure_of_rat_image_le_le_eq {a b : ‚Ñö} (hab : a ‚â§ b) :
  closure (of_rat '' {q:‚Ñö | a ‚â§ q ‚àß q ‚â§ b}) = {r:‚Ñù | of_rat a ‚â§ r ‚àß r ‚â§ of_rat b} :=
_-/

lemma compact_Icc {a b : ‚Ñù} : compact (Icc a b) :=
compact_of_totally_bounded_is_closed
  (real.totally_bounded_Icc a b)
  (is_closed_inter (is_closed_ge' a) (is_closed_le' b))

instance : proper_space ‚Ñù :=
{ compact_ball := Œªx r, by rw closed_ball_Icc; apply compact_Icc }

lemma real.bounded_iff_bdd_below_bdd_above {s : set ‚Ñù} : bounded s ‚Üî bdd_below s ‚àß bdd_above s :=
‚ü®begin
  assume bdd,
  rcases (bounded_iff_subset_ball 0).1 bdd with ‚ü®r, hr‚ü©, -- hr : s ‚äÜ closed_ball 0 r
  rw closed_ball_Icc at hr, -- hr : s ‚äÜ Icc (0 - r) (0 + r)
  exact ‚ü®‚ü®-r, Œªy hy, by simpa using (hr hy).1‚ü©, ‚ü®r, Œªy hy, by simpa using (hr hy).2‚ü©‚ü©
end,
begin
  rintros ‚ü®‚ü®m, hm‚ü©, ‚ü®M, hM‚ü©‚ü©,
  have I : s ‚äÜ Icc m M := Œªx hx, ‚ü®hm hx, hM hx‚ü©,
  have : Icc m M = closed_ball ((m+M)/2) ((M-m)/2) :=
    by rw closed_ball_Icc; congr; ring,
  rw this at I,
  exact bounded.subset I bounded_closed_ball
end‚ü©

end
