/-
Copyright (c) 2019 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Reid Barton, Patrick Massot, Scott Morrison
-/
import category_theory.monad.limits
import topology.uniform_space.completion
import topology.category.Top.basic

/-!
# The category of uniform spaces

We construct the category of uniform spaces, show that the complete separated uniform spaces
form a reflective subcategory, and hence possess all limits that uniform spaces do.

TODO: show that uniform spaces actually have all limits!
-/

universes u

open category_theory

/-- A (bundled) uniform space. -/
@[reducible] def UniformSpace : Type (u+1) := bundled uniform_space

namespace UniformSpace

instance (x : UniformSpace) : uniform_space x := x.str

/-- Construct a bundled `UniformSpace` from the underlying type and the typeclass. -/
def of (Œ± : Type u) [uniform_space Œ±] : UniformSpace := ‚ü®Œ±‚ü©

/-- The information required to build morphisms for `UniformSpace`. -/
instance concrete_category_uniform_continuous : unbundled_hom @uniform_continuous :=
‚ü®@uniform_continuous_id, @uniform_continuous.comp‚ü©

instance (X Y : UniformSpace) : has_coe_to_fun (X ‚ü∂ Y) :=
{ F := Œª _, X ‚Üí Y, coe := category_theory.functor.map (forget UniformSpace) }

@[simp] lemma coe_comp {X Y Z : UniformSpace} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  (f ‚â´ g : X ‚Üí Z) = g ‚àò f := rfl
@[simp] lemma coe_id (X : UniformSpace) : (ùüô X : X ‚Üí X) = id := rfl
@[simp] lemma coe_mk {X Y : UniformSpace} (f : X ‚Üí Y) (hf : uniform_continuous f) :
  ((‚ü®f, hf‚ü© : X ‚ü∂ Y) : X ‚Üí Y) = f := rfl

lemma hom_ext {X Y : UniformSpace} {f g : X ‚ü∂ Y} : (f : X ‚Üí Y) = g ‚Üí f = g := subtype.eq

/-- The forgetful functor from uniform spaces to topological spaces. -/
instance has_forget_to_Top : has_forget‚ÇÇ UniformSpace.{u} Top.{u} :=
unbundled_hom.mk_has_forget‚ÇÇ
  @uniform_space.to_topological_space
  @uniform_continuous.continuous

end UniformSpace

/-- A (bundled) complete separated uniform space. -/
structure CpltSepUniformSpace :=
(Œ± : Type u)
[is_uniform_space : uniform_space Œ±]
[is_complete_space : complete_space Œ±]
[is_separated : separated_space Œ±]

namespace CpltSepUniformSpace

instance : has_coe_to_sort CpltSepUniformSpace :=
{ S := Type u, coe := CpltSepUniformSpace.Œ± }

attribute [instance] is_uniform_space is_complete_space is_separated

def to_UniformSpace (X : CpltSepUniformSpace) : UniformSpace :=
UniformSpace.of X

instance (X : CpltSepUniformSpace) : complete_space ((to_UniformSpace X).Œ±) := CpltSepUniformSpace.is_complete_space X
instance (X : CpltSepUniformSpace) : separated_space ((to_UniformSpace X).Œ±) := CpltSepUniformSpace.is_separated X

/-- Construct a bundled `UniformSpace` from the underlying type and the appropriate typeclasses. -/
def of (X : Type u) [uniform_space X] [complete_space X] [separated_space X] : CpltSepUniformSpace := ‚ü®X‚ü©

/-- The category instance on `CpltSepUniformSpace`. -/
instance category : category CpltSepUniformSpace :=
induced_category.category to_UniformSpace

/-- The concrete category instance on `CpltSepUniformSpace`. -/
instance concrete_category : concrete_category CpltSepUniformSpace :=
induced_category.concrete_category to_UniformSpace

instance has_forget_to_UniformSpace : has_forget‚ÇÇ CpltSepUniformSpace UniformSpace :=
induced_category.has_forget‚ÇÇ to_UniformSpace

end CpltSepUniformSpace

namespace UniformSpace

open uniform_space
open CpltSepUniformSpace

/-- The functor turning uniform spaces into complete separated uniform spaces. -/
noncomputable def completion_functor : UniformSpace ‚•§ CpltSepUniformSpace :=
{ obj := Œª X, CpltSepUniformSpace.of (completion X),
  map := Œª X Y f, ‚ü®completion.map f.1, completion.uniform_continuous_map‚ü©,
  map_id' := Œª X, subtype.eq completion.map_id,
  map_comp' := Œª X Y Z f g, subtype.eq (completion.map_comp g.property f.property).symm, }.

/-- The inclusion of any uniform spaces into its completion. -/
def completion_hom (X : UniformSpace) :
  X ‚ü∂ (forget‚ÇÇ CpltSepUniformSpace UniformSpace).obj (completion_functor.obj X) :=
{ val := (coe : X ‚Üí completion X),
  property := completion.uniform_continuous_coe X }

@[simp] lemma completion_hom_val (X : UniformSpace) (x) :
  (completion_hom X) x = (x : completion X) := rfl

/-- The mate of a morphism from a `UniformSpace` to a `CpltSepUniformSpace`. -/
noncomputable def extension_hom {X : UniformSpace} {Y : CpltSepUniformSpace}
  (f : X ‚ü∂ (forget‚ÇÇ CpltSepUniformSpace UniformSpace).obj Y) :
  completion_functor.obj X ‚ü∂ Y :=
{ val := completion.extension f,
  property := completion.uniform_continuous_extension }

@[simp] lemma extension_hom_val {X : UniformSpace} {Y : CpltSepUniformSpace}
  (f : X ‚ü∂ (forget‚ÇÇ _ _).obj Y) (x) :
  (extension_hom f) x = completion.extension f x := rfl.

@[simp] lemma extension_comp_coe {X : UniformSpace} {Y : CpltSepUniformSpace}
(f : to_UniformSpace (CpltSepUniformSpace.of (completion X)) ‚ü∂ to_UniformSpace Y) :
extension_hom (completion_hom X ‚â´ f) = f :=
by { apply subtype.eq, funext x, exact congr_fun (completion.extension_comp_coe f.property) x }

/-- The completion functor is left adjoint to the forgetful functor. -/
noncomputable def adj : completion_functor ‚ä£ forget‚ÇÇ CpltSepUniformSpace UniformSpace :=
adjunction.mk_of_hom_equiv
{ hom_equiv := Œª X Y,
  { to_fun := Œª f, completion_hom X ‚â´ f,
    inv_fun := Œª f, extension_hom f,
    left_inv := Œª f, by { dsimp, erw extension_comp_coe },
    right_inv := Œª f,
    begin
      apply subtype.eq, funext x, cases f,
      exact @completion.extension_coe _ _ _ _ _ (CpltSepUniformSpace.separated_space _) f_property _
    end },
  hom_equiv_naturality_left_symm' := Œª X X' Y f g,
  begin
    apply hom_ext, funext x, dsimp,
    erw [coe_comp, ‚Üêcompletion.extension_map],
    refl, exact g.property, exact f.property,
  end }

noncomputable instance : is_right_adjoint (forget‚ÇÇ CpltSepUniformSpace UniformSpace) :=
‚ü®completion_functor, adj‚ü©
noncomputable instance : reflective (forget‚ÇÇ CpltSepUniformSpace UniformSpace) := {}

open category_theory.limits

-- TODO Once someone defines `has_limits UniformSpace`, turn this into an instance.
noncomputable example [has_limits.{u} UniformSpace.{u}] : has_limits.{u} CpltSepUniformSpace.{u} :=
has_limits_of_reflective $ forget‚ÇÇ CpltSepUniformSpace UniformSpace

end UniformSpace
