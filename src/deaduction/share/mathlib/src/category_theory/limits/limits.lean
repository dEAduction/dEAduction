/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Reid Barton, Mario Carneiro, Scott Morrison, Floris van Doorn
-/
import category_theory.limits.cones
import category_theory.adjunction.basic

open category_theory category_theory.category category_theory.functor opposite

namespace category_theory.limits

universes v u u' u'' w -- declare the `v`'s first; see `category_theory.category` for an explanation

-- See the notes at the top of cones.lean, explaining why we can't allow `J : Prop` here.
variables {J K : Type v} [small_category J] [small_category K]
variables {C : Type u} [category.{v} C]

variables {F : J ‚•§ C}

/-- A cone `t` on `F` is a limit cone if each cone on `F` admits a unique
  cone morphism to `t`. -/
@[nolint has_inhabited_instance]
structure is_limit (t : cone F) :=
(lift  : Œ† (s : cone F), s.X ‚ü∂ t.X)
(fac'  : ‚àÄ (s : cone F) (j : J), lift s ‚â´ t.œÄ.app j = s.œÄ.app j . obviously)
(uniq' : ‚àÄ (s : cone F) (m : s.X ‚ü∂ t.X) (w : ‚àÄ j : J, m ‚â´ t.œÄ.app j = s.œÄ.app j),
  m = lift s . obviously)

restate_axiom is_limit.fac'
attribute [simp, reassoc] is_limit.fac
restate_axiom is_limit.uniq'

namespace is_limit

instance subsingleton {t : cone F} : subsingleton (is_limit t) :=
‚ü®by intros P Q; cases P; cases Q; congr; ext; solve_by_elim‚ü©

/- Repackaging the definition in terms of cone morphisms. -/

/-- The universal morphism from any other cone to a limit cone. -/
def lift_cone_morphism {t : cone F} (h : is_limit t) (s : cone F) : s ‚ü∂ t :=
{ hom := h.lift s }

lemma uniq_cone_morphism {s t : cone F} (h : is_limit t) {f f' : s ‚ü∂ t} :
  f = f' :=
have ‚àÄ {g : s ‚ü∂ t}, g = h.lift_cone_morphism s, by intro g; ext; exact h.uniq _ _ g.w,
this.trans this.symm

/--
Alternative constructor for `is_limit`,
providing a morphism of cones rather than a morphism between the cone points
and separately the factorisation condition.
-/
def mk_cone_morphism {t : cone F}
  (lift : Œ† (s : cone F), s ‚ü∂ t)
  (uniq' : ‚àÄ (s : cone F) (m : s ‚ü∂ t), m = lift s) : is_limit t :=
{ lift := Œª s, (lift s).hom,
  uniq' := Œª s m w,
    have cone_morphism.mk m w = lift s, by apply uniq',
    congr_arg cone_morphism.hom this }

/-- Limit cones on `F` are unique up to isomorphism. -/
def unique_up_to_iso {s t : cone F} (P : is_limit s) (Q : is_limit t) : s ‚âÖ t :=
{ hom := Q.lift_cone_morphism s,
  inv := P.lift_cone_morphism t,
  hom_inv_id' := P.uniq_cone_morphism,
  inv_hom_id' := Q.uniq_cone_morphism }

/-- Limits of `F` are unique up to isomorphism. -/
-- We may later want to prove the coherence of these isomorphisms.
def cone_point_unique_up_to_iso {s t : cone F} (P : is_limit s) (Q : is_limit t) : s.X ‚âÖ t.X :=
(cones.forget F).map_iso (unique_up_to_iso P Q)

/-- Transport evidence that a cone is a limit cone across an isomorphism of cones. -/
def of_iso_limit {r t : cone F} (P : is_limit r) (i : r ‚âÖ t) : is_limit t :=
is_limit.mk_cone_morphism
  (Œª s, P.lift_cone_morphism s ‚â´ i.hom)
  (Œª s m, by rw ‚Üêi.comp_inv_eq; apply P.uniq_cone_morphism)

variables {t : cone F}

lemma hom_lift (h : is_limit t) {W : C} (m : W ‚ü∂ t.X) :
  m = h.lift { X := W, œÄ := { app := Œª b, m ‚â´ t.œÄ.app b } } :=
h.uniq { X := W, œÄ := { app := Œª b, m ‚â´ t.œÄ.app b } } m (Œª b, rfl)

/-- Two morphisms into a limit are equal if their compositions with
  each cone morphism are equal. -/
lemma hom_ext (h : is_limit t) {W : C} {f f' : W ‚ü∂ t.X}
  (w : ‚àÄ j, f ‚â´ t.œÄ.app j = f' ‚â´ t.œÄ.app j) : f = f' :=
by rw [h.hom_lift f, h.hom_lift f']; congr; exact funext w

/-- The universal property of a limit cone: a map `W ‚ü∂ X` is the same as
  a cone on `F` with vertex `W`. -/
def hom_iso (h : is_limit t) (W : C) : (W ‚ü∂ t.X) ‚âÖ ((const J).obj W ‚ü∂ F) :=
{ hom := Œª f, (t.extend f).œÄ,
  inv := Œª œÄ, h.lift { X := W, œÄ := œÄ },
  hom_inv_id' := by ext f; apply h.hom_ext; intro j; simp; dsimp; refl }

@[simp] lemma hom_iso_hom (h : is_limit t) {W : C} (f : W ‚ü∂ t.X) :
  (is_limit.hom_iso h W).hom f = (t.extend f).œÄ := rfl

/-- The limit of `F` represents the functor taking `W` to
  the set of cones on `F` with vertex `W`. -/
def nat_iso (h : is_limit t) : yoneda.obj t.X ‚âÖ F.cones :=
nat_iso.of_components (Œª W, is_limit.hom_iso h (unop W)) (by tidy).

/--
Another, more explicit, formulation of the universal property of a limit cone.
See also `hom_iso`.
-/
def hom_iso' (h : is_limit t) (W : C) :
  ((W ‚ü∂ t.X) : Type v) ‚âÖ { p : Œ† j, W ‚ü∂ F.obj j // ‚àÄ {j j'} (f : j ‚ü∂ j'), p j ‚â´ F.map f = p j' } :=
h.hom_iso W ‚â™‚â´
{ hom := Œª œÄ,
  ‚ü®Œª j, œÄ.app j, Œª j j' f,
   by convert ‚Üê(œÄ.naturality f).symm; apply id_comp‚ü©,
  inv := Œª p,
  { app := Œª j, p.1 j,
    naturality' := Œª j j' f, begin dsimp, rw [id_comp], exact (p.2 f).symm end } }

/-- If G : C ‚Üí D is a faithful functor which sends t to a limit cone,
  then it suffices to check that the induced maps for the image of t
  can be lifted to maps of C. -/
def of_faithful {t : cone F} {D : Type u'} [category.{v} D] (G : C ‚•§ D) [faithful G]
  (ht : is_limit (G.map_cone t)) (lift : Œ† (s : cone F), s.X ‚ü∂ t.X)
  (h : ‚àÄ s, G.map (lift s) = ht.lift (G.map_cone s)) : is_limit t :=
{ lift := lift,
  fac' := Œª s j, by apply G.map_injective; rw [G.map_comp, h]; apply ht.fac,
  uniq' := Œª s m w, begin
    apply G.map_injective, rw h,
    refine ht.uniq (G.map_cone s) _ (Œª j, _),
    convert ‚Üêcongr_arg (Œª f, G.map f) (w j),
    apply G.map_comp
  end }

/--
If `F` and `G` are naturally isomorphic, then `F.map_cone c` being a limit implies
`G.map_cone c` is also a limit.
-/
def map_cone_equiv {D : Type u'} [category.{v} D] {K : J ‚•§ C} {F G : C ‚•§ D} (h : F ‚âÖ G) {c : cone K}
  (t : is_limit (F.map_cone c)) : is_limit (G.map_cone c) :=
{ lift := Œª s, t.lift ((cones.postcompose (iso_whisker_left K h).inv).obj s) ‚â´ h.hom.app c.X,
  fac' := Œª s j,
  begin
    slice_lhs 2 3 {erw ‚Üê h.hom.naturality (c.œÄ.app j)},
    slice_lhs 1 2 {erw t.fac ((cones.postcompose (iso_whisker_left K h).inv).obj s) j},
    dsimp,
    slice_lhs 2 3 {rw nat_iso.inv_hom_id_app},
    rw category.comp_id,
  end,
  uniq' := Œª s m J,
  begin
    rw ‚Üê cancel_mono (h.inv.app c.X),
    apply t.hom_ext,
    intro j,
    dsimp,
    slice_lhs 2 3 {erw ‚Üê h.inv.naturality (c.œÄ.app j)},
    slice_lhs 1 2 {erw J j},
    conv_rhs {congr, rw [category.assoc, nat_iso.hom_inv_id_app, comp_id]},
    apply (t.fac ((cones.postcompose (iso_whisker_left K h).inv).obj s) j).symm
  end }

/--
A cone is a limit cone exactly if
there is a unique cone morphism from any other cone.
-/
def iso_unique_cone_morphism {t : cone F} :
  is_limit t ‚âÖ Œ† s, unique (s ‚ü∂ t) :=
{ hom := Œª h s,
  { default := h.lift_cone_morphism s,
    uniq := Œª _, h.uniq_cone_morphism },
  inv := Œª h,
  { lift := Œª s, (h s).default.hom,
    uniq' := Œª s f w, congr_arg cone_morphism.hom ((h s).uniq ‚ü®f, w‚ü©) } }

/--
Given two functors which have equivalent categories of cones, we can transport a limiting cone across
the equivalence.
-/
def of_cone_equiv {D : Type u'} [category.{v} D] {G : K ‚•§ D}
  (h : cone G ‚•§ cone F) [is_right_adjoint h] {c : cone G} (t : is_limit c) :
  is_limit (h.obj c) :=
mk_cone_morphism
  (Œª s, (adjunction.of_right_adjoint h).hom_equiv s c (t.lift_cone_morphism _))
  (Œª s m, (adjunction.eq_hom_equiv_apply _ _ _).2 t.uniq_cone_morphism )

namespace of_nat_iso
variables {X : C} (h : yoneda.obj X ‚âÖ F.cones)

/-- If `F.cones` is represented by `X`, each morphism `f : Y ‚ü∂ X` gives a cone with cone point `Y`. -/
def cone_of_hom {Y : C} (f : Y ‚ü∂ X) : cone F :=
{ X := Y, œÄ := h.hom.app (op Y) f }

/-- If `F.cones` is represented by `X`, each cone `s` gives a morphism `s.X ‚ü∂ X`. -/
def hom_of_cone (s : cone F) : s.X ‚ü∂ X := h.inv.app (op s.X) s.œÄ

@[simp] lemma cone_of_hom_of_cone (s : cone F) : cone_of_hom h (hom_of_cone h s) = s :=
begin
  dsimp [cone_of_hom, hom_of_cone], cases s, congr, dsimp,
  exact congr_fun (congr_fun (congr_arg nat_trans.app h.inv_hom_id) (op s_X)) s_œÄ,
end

@[simp] lemma hom_of_cone_of_hom {Y : C} (f : Y ‚ü∂ X) : hom_of_cone h (cone_of_hom h f) = f :=
congr_fun (congr_fun (congr_arg nat_trans.app h.hom_inv_id) (op Y)) f

/-- If `F.cones` is represented by `X`, the cone corresponding to the identity morphism on `X`
will be a limit cone. -/
def limit_cone : cone F :=
cone_of_hom h (ùüô X)

/-- If `F.cones` is represented by `X`, the cone corresponding to a morphism `f : Y ‚ü∂ X` is
the limit cone extended by `f`. -/
lemma cone_of_hom_fac {Y : C} (f : Y ‚ü∂ X) :
cone_of_hom h f = (limit_cone h).extend f :=
begin
  dsimp [cone_of_hom, limit_cone, cone.extend],
  congr,
  ext j,
  have t := congr_fun (h.hom.naturality f.op) (ùüô X),
  dsimp at t,
  simp only [comp_id] at t,
  rw congr_fun (congr_arg nat_trans.app t) j,
  refl,
end

/-- If `F.cones` is represented by `X`, any cone is the extension of the limit cone by the
corresponding morphism. -/
lemma cone_fac (s : cone F) : (limit_cone h).extend (hom_of_cone h s) = s :=
begin
  rw ‚Üêcone_of_hom_of_cone h s,
  conv_lhs { simp only [hom_of_cone_of_hom] },
  apply (cone_of_hom_fac _ _).symm,
end

end of_nat_iso

section
open of_nat_iso

/--
If `F.cones` is representable, then the cone corresponding to the identity morphism on
the representing object is a limit cone.
-/
def of_nat_iso {X : C} (h : yoneda.obj X ‚âÖ F.cones) :
  is_limit (limit_cone h) :=
{ lift := Œª s, hom_of_cone h s,
  fac' := Œª s j,
  begin
    have h := cone_fac h s,
    cases s,
    injection h with h‚ÇÅ h‚ÇÇ,
    simp only [heq_iff_eq] at h‚ÇÇ,
    conv_rhs { rw ‚Üê h‚ÇÇ }, refl,
  end,
  uniq' := Œª s m w,
  begin
    rw ‚Üêhom_of_cone_of_hom h m,
    congr,
    rw cone_of_hom_fac,
    dsimp, cases s, congr,
    ext j, exact w j,
  end }
end

end is_limit

/-- A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique
  cocone morphism from `t`. -/
@[nolint has_inhabited_instance]
structure is_colimit (t : cocone F) :=
(desc  : Œ† (s : cocone F), t.X ‚ü∂ s.X)
(fac'  : ‚àÄ (s : cocone F) (j : J), t.Œπ.app j ‚â´ desc s = s.Œπ.app j . obviously)
(uniq' : ‚àÄ (s : cocone F) (m : t.X ‚ü∂ s.X) (w : ‚àÄ j : J, t.Œπ.app j ‚â´ m = s.Œπ.app j),
  m = desc s . obviously)

restate_axiom is_colimit.fac'
attribute [simp] is_colimit.fac
restate_axiom is_colimit.uniq'

namespace is_colimit

instance subsingleton {t : cocone F} : subsingleton (is_colimit t) :=
‚ü®by intros P Q; cases P; cases Q; congr; ext; solve_by_elim‚ü©

/- Repackaging the definition in terms of cone morphisms. -/

/-- The universal morphism from a colimit cocone to any other cone. -/
def desc_cocone_morphism {t : cocone F} (h : is_colimit t) (s : cocone F) : t ‚ü∂ s :=
{ hom := h.desc s }

lemma uniq_cocone_morphism {s t : cocone F} (h : is_colimit t) {f f' : t ‚ü∂ s} :
  f = f' :=
have ‚àÄ {g : t ‚ü∂ s}, g = h.desc_cocone_morphism s, by intro g; ext; exact h.uniq _ _ g.w,
this.trans this.symm

/--
Alternative constructor for `is_colimit`,
providing a morphism of cocones rather than a morphism between the cocone points
and separately the factorisation condition.
-/
def mk_cocone_morphism {t : cocone F}
  (desc : Œ† (s : cocone F), t ‚ü∂ s)
  (uniq' : ‚àÄ (s : cocone F) (m : t ‚ü∂ s), m = desc s) : is_colimit t :=
{ desc := Œª s, (desc s).hom,
  uniq' := Œª s m w,
    have cocone_morphism.mk m w = desc s, by apply uniq',
    congr_arg cocone_morphism.hom this }

/-- Limit cones on `F` are unique up to isomorphism. -/
def unique_up_to_iso {s t : cocone F} (P : is_colimit s) (Q : is_colimit t) : s ‚âÖ t :=
{ hom := P.desc_cocone_morphism t,
  inv := Q.desc_cocone_morphism s,
  hom_inv_id' := P.uniq_cocone_morphism,
  inv_hom_id' := Q.uniq_cocone_morphism }

/-- Colimits of `F` are unique up to isomorphism. -/
-- We may later want to prove the coherence of these isomorphisms.
def cocone_point_unique_up_to_iso {s t : cocone F} (P : is_colimit s) (Q : is_colimit t) : s.X ‚âÖ t.X :=
(cocones.forget F).map_iso (unique_up_to_iso P Q)

/-- Transport evidence that a cocone is a colimit cocone across an isomorphism of cocones. -/
def of_iso_colimit {r t : cocone F} (P : is_colimit r) (i : r ‚âÖ t) : is_colimit t :=
is_colimit.mk_cocone_morphism
  (Œª s, i.inv ‚â´ P.desc_cocone_morphism s)
  (Œª s m, by rw i.eq_inv_comp; apply P.uniq_cocone_morphism)

variables {t : cocone F}

lemma hom_desc (h : is_colimit t) {W : C} (m : t.X ‚ü∂ W) :
  m = h.desc { X := W, Œπ := { app := Œª b, t.Œπ.app b ‚â´ m,
    naturality' := by intros; erw [‚Üêassoc, t.Œπ.naturality, comp_id, comp_id] } } :=
h.uniq { X := W, Œπ := { app := Œª b, t.Œπ.app b ‚â´ m, naturality' := _ } } m (Œª b, rfl)

/-- Two morphisms out of a colimit are equal if their compositions with
  each cocone morphism are equal. -/
lemma hom_ext (h : is_colimit t) {W : C} {f f' : t.X ‚ü∂ W}
  (w : ‚àÄ j, t.Œπ.app j ‚â´ f = t.Œπ.app j ‚â´ f') : f = f' :=
by rw [h.hom_desc f, h.hom_desc f']; congr; exact funext w

/-- The universal property of a colimit cocone: a map `X ‚ü∂ W` is the same as
  a cocone on `F` with vertex `W`. -/
def hom_iso (h : is_colimit t) (W : C) : (t.X ‚ü∂ W) ‚âÖ (F ‚ü∂ (const J).obj W) :=
{ hom := Œª f, (t.extend f).Œπ,
  inv := Œª Œπ, h.desc { X := W, Œπ := Œπ },
  hom_inv_id' := by ext f; apply h.hom_ext; intro j; simp; dsimp; refl }

@[simp] lemma hom_iso_hom (h : is_colimit t) {W : C} (f : t.X ‚ü∂ W) :
  (is_colimit.hom_iso h W).hom f = (t.extend f).Œπ := rfl

/-- The colimit of `F` represents the functor taking `W` to
  the set of cocones on `F` with vertex `W`. -/
def nat_iso (h : is_colimit t) : coyoneda.obj (op t.X) ‚âÖ F.cocones :=
nat_iso.of_components (is_colimit.hom_iso h) (by intros; ext; dsimp; rw ‚Üêassoc; refl)

/--
Another, more explicit, formulation of the universal property of a colimit cocone.
See also `hom_iso`.
-/
def hom_iso' (h : is_colimit t) (W : C) :
  ((t.X ‚ü∂ W) : Type v) ‚âÖ { p : Œ† j, F.obj j ‚ü∂ W // ‚àÄ {j j' : J} (f : j ‚ü∂ j'), F.map f ‚â´ p j' = p j } :=
h.hom_iso W ‚â™‚â´
{ hom := Œª Œπ,
  ‚ü®Œª j, Œπ.app j, Œª j j' f,
   by convert ‚Üê(Œπ.naturality f); apply comp_id‚ü©,
  inv := Œª p,
  { app := Œª j, p.1 j,
    naturality' := Œª j j' f, begin dsimp, rw [comp_id], exact (p.2 f) end } }

/-- If G : C ‚Üí D is a faithful functor which sends t to a colimit cocone,
  then it suffices to check that the induced maps for the image of t
  can be lifted to maps of C. -/
def of_faithful {t : cocone F} {D : Type u'} [category.{v} D] (G : C ‚•§ D) [faithful G]
  (ht : is_colimit (G.map_cocone t)) (desc : Œ† (s : cocone F), t.X ‚ü∂ s.X)
  (h : ‚àÄ s, G.map (desc s) = ht.desc (G.map_cocone s)) : is_colimit t :=
{ desc := desc,
  fac' := Œª s j, by apply G.map_injective; rw [G.map_comp, h]; apply ht.fac,
  uniq' := Œª s m w, begin
    apply G.map_injective, rw h,
    refine ht.uniq (G.map_cocone s) _ (Œª j, _),
    convert ‚Üêcongr_arg (Œª f, G.map f) (w j),
    apply G.map_comp
  end }

/--
A cocone is a colimit cocone exactly if
there is a unique cocone morphism from any other cocone.
-/
def iso_unique_cocone_morphism {t : cocone F} :
  is_colimit t ‚âÖ Œ† s, unique (t ‚ü∂ s) :=
{ hom := Œª h s,
  { default := h.desc_cocone_morphism s,
    uniq := Œª _, h.uniq_cocone_morphism },
  inv := Œª h,
  { desc := Œª s, (h s).default.hom,
    uniq' := Œª s f w, congr_arg cocone_morphism.hom ((h s).uniq ‚ü®f, w‚ü©) } }

/--
Given two functors which have equivalent categories of cocones, we can transport a limiting cocone
across the equivalence.
-/
def of_cocone_equiv {D : Type u'} [category.{v} D] {G : K ‚•§ D}
  (h : cocone G ‚•§ cocone F) [is_left_adjoint h] {c : cocone G} (t : is_colimit c) :
  is_colimit (h.obj c) :=
mk_cocone_morphism
  (Œª s, ((adjunction.of_left_adjoint h).hom_equiv c s).symm (t.desc_cocone_morphism _))
  (Œª s m, (adjunction.hom_equiv_apply_eq _ _ _).1 t.uniq_cocone_morphism)

namespace of_nat_iso
variables {X : C} (h : coyoneda.obj (op X) ‚âÖ F.cocones)

/-- If `F.cocones` is corepresented by `X`, each morphism `f : X ‚ü∂ Y` gives a cocone with cone point `Y`. -/
def cocone_of_hom {Y : C} (f : X ‚ü∂ Y) : cocone F :=
{ X := Y, Œπ := h.hom.app Y f }

/-- If `F.cocones` is corepresented by `X`, each cocone `s` gives a morphism `X ‚ü∂ s.X`. -/
def hom_of_cocone (s : cocone F) : X ‚ü∂ s.X := h.inv.app s.X s.Œπ

@[simp] lemma cocone_of_hom_of_cocone (s : cocone F) : cocone_of_hom h (hom_of_cocone h s) = s :=
begin
  dsimp [cocone_of_hom, hom_of_cocone], cases s, congr, dsimp,
  exact congr_fun (congr_fun (congr_arg nat_trans.app h.inv_hom_id) s_X) s_Œπ,
end

@[simp] lemma hom_of_cocone_of_hom {Y : C} (f : X ‚ü∂ Y) : hom_of_cocone h (cocone_of_hom h f) = f :=
congr_fun (congr_fun (congr_arg nat_trans.app h.hom_inv_id) Y) f

/-- If `F.cocones` is corepresented by `X`, the cocone corresponding to the identity morphism on `X`
will be a colimit cocone. -/
def colimit_cocone : cocone F :=
cocone_of_hom h (ùüô X)

/-- If `F.cocones` is corepresented by `X`, the cocone corresponding to a morphism `f : Y ‚ü∂ X` is
the colimit cocone extended by `f`. -/
lemma cocone_of_hom_fac {Y : C} (f : X ‚ü∂ Y) :
cocone_of_hom h f = (colimit_cocone h).extend f :=
begin
  dsimp [cocone_of_hom, colimit_cocone, cocone.extend],
  congr,
  ext j,
  have t := congr_fun (h.hom.naturality f) (ùüô X),
  dsimp at t,
  simp only [id_comp] at t,
  rw congr_fun (congr_arg nat_trans.app t) j,
  refl,
end

/-- If `F.cocones` is corepresented by `X`, any cocone is the extension of the colimit cocone by the
corresponding morphism. -/
lemma cocone_fac (s : cocone F) : (colimit_cocone h).extend (hom_of_cocone h s) = s :=
begin
  rw ‚Üêcocone_of_hom_of_cocone h s,
  conv_lhs { simp only [hom_of_cocone_of_hom] },
  apply (cocone_of_hom_fac _ _).symm,
end

end of_nat_iso

section
open of_nat_iso

/--
If `F.cocones` is corepresentable, then the cocone corresponding to the identity morphism on
the representing object is a colimit cocone.
-/
def of_nat_iso {X : C} (h : coyoneda.obj (op X) ‚âÖ F.cocones) :
  is_colimit (colimit_cocone h) :=
{ desc := Œª s, hom_of_cocone h s,
  fac' := Œª s j,
  begin
    have h := cocone_fac h s,
    cases s,
    injection h with h‚ÇÅ h‚ÇÇ,
    simp only [heq_iff_eq] at h‚ÇÇ,
    conv_rhs { rw ‚Üê h‚ÇÇ }, refl,
  end,
  uniq' := Œª s m w,
  begin
    rw ‚Üêhom_of_cocone_of_hom h m,
    congr,
    rw cocone_of_hom_fac,
    dsimp, cases s, congr,
    ext j, exact w j,
  end }
end

end is_colimit

section limit

/-- `has_limit F` represents a particular chosen limit of the diagram `F`. -/
class has_limit (F : J ‚•§ C) :=
(cone : cone F)
(is_limit : is_limit cone)

variables (J C)

/-- `C` has limits of shape `J` if we have chosen a particular limit of
  every functor `F : J ‚•§ C`. -/
class has_limits_of_shape :=
(has_limit : Œ† F : J ‚•§ C, has_limit F)

/-- `C` has all (small) limits if it has limits of every shape. -/
class has_limits :=
(has_limits_of_shape : Œ† (J : Type v) [ùí• : small_category J], has_limits_of_shape J C)

variables {J C}

@[priority 100] -- see Note [lower instance priority]
instance has_limit_of_has_limits_of_shape
  {J : Type v} [small_category J] [H : has_limits_of_shape J C] (F : J ‚•§ C) : has_limit F :=
has_limits_of_shape.has_limit F

@[priority 100] -- see Note [lower instance priority]
instance has_limits_of_shape_of_has_limits
  {J : Type v} [small_category J] [H : has_limits.{v} C] : has_limits_of_shape J C :=
has_limits.has_limits_of_shape J

/- Interface to the `has_limit` class. -/

/-- The chosen limit cone of a functor. -/
def limit.cone (F : J ‚•§ C) [has_limit F] : cone F := has_limit.cone

/-- The chosen limit object of a functor. -/
def limit (F : J ‚•§ C) [has_limit F] := (limit.cone F).X

/-- The projection from the chosen limit object to a value of the functor. -/
def limit.œÄ (F : J ‚•§ C) [has_limit F] (j : J) : limit F ‚ü∂ F.obj j :=
(limit.cone F).œÄ.app j

@[simp] lemma limit.cone_œÄ {F : J ‚•§ C} [has_limit F] (j : J) :
  (limit.cone F).œÄ.app j = limit.œÄ _ j := rfl

@[simp] lemma limit.w (F : J ‚•§ C) [has_limit F] {j j' : J} (f : j ‚ü∂ j') :
  limit.œÄ F j ‚â´ F.map f = limit.œÄ F j' := (limit.cone F).w f

/-- Evidence that the chosen cone is a limit cone. -/
def limit.is_limit (F : J ‚•§ C) [has_limit F] : is_limit (limit.cone F) :=
has_limit.is_limit.{v}

/-- The morphism from the cone point of any other cone to the chosen limit object. -/
def limit.lift (F : J ‚•§ C) [has_limit F] (c : cone F) : c.X ‚ü∂ limit F :=
(limit.is_limit F).lift c

@[simp] lemma limit.is_limit_lift {F : J ‚•§ C} [has_limit F] (c : cone F) :
  (limit.is_limit F).lift c = limit.lift F c := rfl

@[simp, reassoc] lemma limit.lift_œÄ {F : J ‚•§ C} [has_limit F] (c : cone F) (j : J) :
  limit.lift F c ‚â´ limit.œÄ F j = c.œÄ.app j :=
is_limit.fac _ c j

/-- The cone morphism from any cone to the chosen limit cone. -/
def limit.cone_morphism {F : J ‚•§ C} [has_limit F] (c : cone F) :
  c ‚ü∂ (limit.cone F) :=
(limit.is_limit F).lift_cone_morphism c

@[simp] lemma limit.cone_morphism_hom {F : J ‚•§ C} [has_limit F] (c : cone F) :
  (limit.cone_morphism c).hom = limit.lift F c := rfl
lemma limit.cone_morphism_œÄ {F : J ‚•§ C} [has_limit F] (c : cone F) (j : J) :
  (limit.cone_morphism c).hom ‚â´ limit.œÄ F j = c.œÄ.app j :=
by simp

@[ext] lemma limit.hom_ext {F : J ‚•§ C} [has_limit F] {X : C} {f f' : X ‚ü∂ limit F}
  (w : ‚àÄ j, f ‚â´ limit.œÄ F j = f' ‚â´ limit.œÄ F j) : f = f' :=
(limit.is_limit F).hom_ext w

/--
The isomorphism (in `Type`) between
morphisms from a specified object `W` to the limit object,
and cones with cone point `W`.
-/
def limit.hom_iso (F : J ‚•§ C) [has_limit F] (W : C) : (W ‚ü∂ limit F) ‚âÖ (F.cones.obj (op W)) :=
(limit.is_limit F).hom_iso W

@[simp] lemma limit.hom_iso_hom (F : J ‚•§ C) [has_limit F] {W : C} (f : W ‚ü∂ limit F) :
  (limit.hom_iso F W).hom f = (const J).map f ‚â´ (limit.cone F).œÄ :=
(limit.is_limit F).hom_iso_hom f

/--
The isomorphism (in `Type`) between
morphisms from a specified object `W` to the limit object,
and an explicit componentwise description of cones with cone point `W`.
-/
def limit.hom_iso' (F : J ‚•§ C) [has_limit F] (W : C) :
  ((W ‚ü∂ limit F) : Type v) ‚âÖ { p : Œ† j, W ‚ü∂ F.obj j // ‚àÄ {j j' : J} (f : j ‚ü∂ j'), p j ‚â´ F.map f = p j' } :=
(limit.is_limit F).hom_iso' W

lemma limit.lift_extend {F : J ‚•§ C} [has_limit F] (c : cone F) {X : C} (f : X ‚ü∂ c.X) :
  limit.lift F (c.extend f) = f ‚â´ limit.lift F c :=
by obviously

/--
If we've chosen a limit for a functor `F`,
we can transport that choice across a natural isomorphism.
-/
def has_limit_of_iso {F G : J ‚•§ C} [has_limit F] (Œ± : F ‚âÖ G) : has_limit G :=
{ cone := (cones.postcompose Œ±.hom).obj (limit.cone F),
  is_limit :=
  { lift := Œª s, limit.lift F ((cones.postcompose Œ±.inv).obj s),
    fac' := Œª s j,
    begin
      rw [cones.postcompose_obj_œÄ, nat_trans.comp_app, limit.cone_œÄ, ‚Üêcategory.assoc, limit.lift_œÄ],
      simp
    end,
    uniq' := Œª s m w,
    begin
      apply limit.hom_ext, intro j,
      rw [limit.lift_œÄ, cones.postcompose_obj_œÄ, nat_trans.comp_app, ‚Üênat_iso.app_inv, iso.eq_comp_inv],
      simpa using w j
    end } }

/-- If a functor `G` has the same collection of cones as a functor `F`
which has a limit, then `G` also has a limit. -/
-- See the construction of limits from products and equalizers
-- for an example usage.
def has_limit.of_cones_iso {J K : Type v} [small_category J] [small_category K] (F : J ‚•§ C) (G : K ‚•§ C)
  (h : F.cones ‚âÖ G.cones) [has_limit F] : has_limit G :=
‚ü®_, is_limit.of_nat_iso ((is_limit.nat_iso (limit.is_limit F)) ‚â™‚â´ h)‚ü©

section pre
variables (F) [has_limit F] (E : K ‚•§ J) [has_limit (E ‚ãô F)]

/--
The canonical morphism
from the chosen limit of `F`
to the chosen limit of `E ‚ãô F`.
-/
def limit.pre : limit F ‚ü∂ limit (E ‚ãô F) :=
limit.lift (E ‚ãô F)
  { X := limit F,
    œÄ := { app := Œª k, limit.œÄ F (E.obj k) } }

@[simp] lemma limit.pre_œÄ (k : K) : limit.pre F E ‚â´ limit.œÄ (E ‚ãô F) k = limit.œÄ F (E.obj k) :=
by erw is_limit.fac

@[simp] lemma limit.lift_pre (c : cone F) :
  limit.lift F c ‚â´ limit.pre F E = limit.lift (E ‚ãô F) (c.whisker E) :=
by ext; simp

variables {L : Type v} [small_category L]
variables (D : L ‚•§ K) [has_limit (D ‚ãô E ‚ãô F)]

@[simp] lemma limit.pre_pre : limit.pre F E ‚â´ limit.pre (E ‚ãô F) D = limit.pre F (D ‚ãô E) :=
by ext j; erw [assoc, limit.pre_œÄ, limit.pre_œÄ, limit.pre_œÄ]; refl

end pre

section post
variables {D : Type u'} [category.{v} D]

variables (F) [has_limit F] (G : C ‚•§ D) [has_limit (F ‚ãô G)]

/--
The canonical morphism
from `G` applied to the chosen limit of `F`
to the chosen limit of `F ‚ãô G`.
-/
def limit.post : G.obj (limit F) ‚ü∂ limit (F ‚ãô G) :=
limit.lift (F ‚ãô G)
{ X := G.obj (limit F),
  œÄ :=
  { app := Œª j, G.map (limit.œÄ F j),
    naturality' :=
      by intros j j' f; erw [‚ÜêG.map_comp, limits.cone.w, id_comp]; refl } }

@[simp] lemma limit.post_œÄ (j : J) : limit.post F G ‚â´ limit.œÄ (F ‚ãô G) j = G.map (limit.œÄ F j) :=
by erw is_limit.fac

@[simp] lemma limit.lift_post (c : cone F) :
  G.map (limit.lift F c) ‚â´ limit.post F G = limit.lift (F ‚ãô G) (G.map_cone c) :=
by ext; rw [assoc, limit.post_œÄ, ‚ÜêG.map_comp, limit.lift_œÄ, limit.lift_œÄ]; refl

@[simp] lemma limit.post_post
  {E : Type u''} [category.{v} E] (H : D ‚•§ E) [has_limit ((F ‚ãô G) ‚ãô H)] :
/- H G (limit F) ‚ü∂ H (limit (F ‚ãô G)) ‚ü∂ limit ((F ‚ãô G) ‚ãô H) equals -/
/- H G (limit F) ‚ü∂ limit (F ‚ãô (G ‚ãô H)) -/
  H.map (limit.post F G) ‚â´ limit.post (F ‚ãô G) H = limit.post F (G ‚ãô H) :=
by ext; erw [assoc, limit.post_œÄ, ‚ÜêH.map_comp, limit.post_œÄ, limit.post_œÄ]; refl

end post

lemma limit.pre_post {D : Type u'} [category.{v} D]
  (E : K ‚•§ J) (F : J ‚•§ C) (G : C ‚•§ D)
  [has_limit F] [has_limit (E ‚ãô F)] [has_limit (F ‚ãô G)] [has_limit ((E ‚ãô F) ‚ãô G)] :
/- G (limit F) ‚ü∂ G (limit (E ‚ãô F)) ‚ü∂ limit ((E ‚ãô F) ‚ãô G) vs -/
/- G (limit F) ‚ü∂ limit F ‚ãô G ‚ü∂ limit (E ‚ãô (F ‚ãô G)) or -/
  G.map (limit.pre F E) ‚â´ limit.post (E ‚ãô F) G = limit.post F G ‚â´ limit.pre (F ‚ãô G) E :=
by ext; erw [assoc, limit.post_œÄ, ‚ÜêG.map_comp, limit.pre_œÄ, assoc, limit.pre_œÄ, limit.post_œÄ]; refl

open category_theory.equivalence
instance has_limit_equivalence_comp (e : K ‚âå J) [has_limit F] : has_limit (e.functor ‚ãô F) :=
{ cone := cone.whisker e.functor (limit.cone F),
  is_limit :=
  let e' := cones.postcompose (e.inv_fun_id_assoc F).hom in
  { lift := Œª s, limit.lift F (e'.obj (cone.whisker e.inverse s)),
    fac' := Œª s j,
    begin
      dsimp, rw [limit.lift_œÄ], dsimp [e'],
      erw [inv_fun_id_assoc_hom_app, counit_functor, ‚Üês.œÄ.naturality, id_comp]
    end,
    uniq' := Œª s m w,
    begin
      apply limit.hom_ext, intro j,
      erw [limit.lift_œÄ, ‚Üêlimit.w F (e.counit_iso.hom.app j)],
      slice_lhs 1 2 { erw [w (e.inverse.obj j)] }, simp
    end } }

local attribute [elab_simple] inv_fun_id_assoc -- not entirely sure why this is needed

/--
If a `E ‚ãô F` has a chosen limit, and `E` is an equivalence, we can construct a chosen limit of `F`.
-/
def has_limit_of_equivalence_comp (e : K ‚âå J) [has_limit (e.functor ‚ãô F)] : has_limit F :=
begin
  haveI : has_limit (e.inverse ‚ãô e.functor ‚ãô F) := limits.has_limit_equivalence_comp e.symm,
  apply has_limit_of_iso (e.inv_fun_id_assoc F),
end

-- `has_limit_comp_equivalence` and `has_limit_of_comp_equivalence`
-- are proved in `category_theory/adjunction/limits.lean`.

section lim_functor

variables [has_limits_of_shape J C]

/-- `limit F` is functorial in `F`, when `C` has all limits of shape `J`. -/
def lim : (J ‚•§ C) ‚•§ C :=
{ obj := Œª F, limit F,
  map := Œª F G Œ±, limit.lift G
    { X := limit F,
      œÄ :=
      { app := Œª j, limit.œÄ F j ‚â´ Œ±.app j,
        naturality' := Œª j j' f,
          by erw [id_comp, assoc, ‚ÜêŒ±.naturality, ‚Üêassoc, limit.w] } },
  map_comp' := Œª F G H Œ± Œ≤,
    by ext; erw [assoc, is_limit.fac, is_limit.fac, ‚Üêassoc, is_limit.fac, assoc]; refl }

variables {F} {G : J ‚•§ C} (Œ± : F ‚ü∂ G)

@[simp, reassoc] lemma limit.map_œÄ (j : J) : lim.map Œ± ‚â´ limit.œÄ G j = limit.œÄ F j ‚â´ Œ±.app j :=
by apply is_limit.fac

@[simp] lemma limit.lift_map (c : cone F) :
  limit.lift F c ‚â´ lim.map Œ± = limit.lift G ((cones.postcompose Œ±).obj c) :=
by ext; rw [assoc, limit.map_œÄ, ‚Üêassoc, limit.lift_œÄ, limit.lift_œÄ]; refl

lemma limit.map_pre [has_limits_of_shape K C] (E : K ‚•§ J) :
  lim.map Œ± ‚â´ limit.pre G E = limit.pre F E ‚â´ lim.map (whisker_left E Œ±) :=
by ext; rw [assoc, limit.pre_œÄ, limit.map_œÄ, assoc, limit.map_œÄ, ‚Üêassoc, limit.pre_œÄ]; refl

lemma limit.map_pre' [has_limits_of_shape.{v} K C]
  (F : J ‚•§ C) {E‚ÇÅ E‚ÇÇ : K ‚•§ J} (Œ± : E‚ÇÅ ‚ü∂ E‚ÇÇ) :
  limit.pre F E‚ÇÇ = limit.pre F E‚ÇÅ ‚â´ lim.map (whisker_right Œ± F) :=
by ext1; simp [‚Üê category.assoc]

lemma limit.id_pre (F : J ‚•§ C) :
limit.pre F (ùü≠ _) = lim.map (functor.left_unitor F).inv := by tidy

lemma limit.map_post {D : Type u'} [category.{v} D] [has_limits_of_shape J D] (H : C ‚•§ D) :
/- H (limit F) ‚ü∂ H (limit G) ‚ü∂ limit (G ‚ãô H) vs
   H (limit F) ‚ü∂ limit (F ‚ãô H) ‚ü∂ limit (G ‚ãô H) -/
  H.map (lim.map Œ±) ‚â´ limit.post G H = limit.post F H ‚â´ lim.map (whisker_right Œ± H) :=
begin
  ext,
  rw [assoc, limit.post_œÄ, ‚ÜêH.map_comp, limit.map_œÄ, H.map_comp],
  rw [assoc, limit.map_œÄ, ‚Üêassoc, limit.post_œÄ],
  refl
end

/--
The isomorphism between
morphisms from `W` to the cone point of the limit cone for `F`
and cones over `F` with cone point `W`
is natural in `F`.
-/
def lim_yoneda : lim ‚ãô yoneda ‚âÖ category_theory.cones J C :=
nat_iso.of_components (Œª F, nat_iso.of_components (Œª W, limit.hom_iso F (unop W)) (by tidy))
  (by tidy)

end lim_functor

/--
We can transport chosen limits of shape `J` along an equivalence `J ‚âå J'`.
-/
def has_limits_of_shape_of_equivalence {J' : Type v} [small_category J']
  (e : J ‚âå J') [has_limits_of_shape J C] : has_limits_of_shape J' C :=
by { constructor, intro F, apply has_limit_of_equivalence_comp e, apply_instance }

end limit


section colimit

/-- `has_colimit F` represents a particular chosen colimit of the diagram `F`. -/
class has_colimit (F : J ‚•§ C) :=
(cocone : cocone F)
(is_colimit : is_colimit cocone)

variables (J C)

/-- `C` has colimits of shape `J` if we have chosen a particular colimit of
  every functor `F : J ‚•§ C`. -/
class has_colimits_of_shape :=
(has_colimit : Œ† F : J ‚•§ C, has_colimit F)

/-- `C` has all (small) colimits if it has colimits of every shape. -/
class has_colimits :=
(has_colimits_of_shape : Œ† (J : Type v) [ùí• : small_category J], has_colimits_of_shape J C)

variables {J C}

@[priority 100] -- see Note [lower instance priority]
instance has_colimit_of_has_colimits_of_shape
  {J : Type v} [small_category J] [H : has_colimits_of_shape J C] (F : J ‚•§ C) : has_colimit F :=
has_colimits_of_shape.has_colimit F

@[priority 100] -- see Note [lower instance priority]
instance has_colimits_of_shape_of_has_colimits
  {J : Type v} [small_category J] [H : has_colimits.{v} C] : has_colimits_of_shape J C :=
has_colimits.has_colimits_of_shape J

/- Interface to the `has_colimit` class. -/

/-- The chosen colimit cocone of a functor. -/
def colimit.cocone (F : J ‚•§ C) [has_colimit F] : cocone F := has_colimit.cocone

/-- The chosen colimit object of a functor. -/
def colimit (F : J ‚•§ C) [has_colimit F] := (colimit.cocone F).X

/-- The coprojection from a value of the functor to the chosen colimit object. -/
def colimit.Œπ (F : J ‚•§ C) [has_colimit F] (j : J) : F.obj j ‚ü∂ colimit F :=
(colimit.cocone F).Œπ.app j

@[simp] lemma colimit.cocone_Œπ {F : J ‚•§ C} [has_colimit F] (j : J) :
  (colimit.cocone F).Œπ.app j = colimit.Œπ _ j := rfl

@[simp] lemma colimit.w (F : J ‚•§ C) [has_colimit F] {j j' : J} (f : j ‚ü∂ j') :
  F.map f ‚â´ colimit.Œπ F j' = colimit.Œπ F j := (colimit.cocone F).w f

/-- Evidence that the chosen cocone is a colimit cocone. -/
def colimit.is_colimit (F : J ‚•§ C) [has_colimit F] : is_colimit (colimit.cocone F) :=
has_colimit.is_colimit.{v}

/-- The morphism from the chosen colimit object to the cone point of any other cocone. -/
def colimit.desc (F : J ‚•§ C) [has_colimit F] (c : cocone F) : colimit F ‚ü∂ c.X :=
(colimit.is_colimit F).desc c

@[simp] lemma colimit.is_colimit_desc {F : J ‚•§ C} [has_colimit F] (c : cocone F) :
  (colimit.is_colimit F).desc c = colimit.desc F c := rfl

/--
We have lots of lemmas describing how to simplify `colimit.Œπ F j ‚â´ _`,
and combined with `colimit.ext` we rely on these lemmas for many calculations.

However, since `category.assoc` is a `@[simp]` lemma, often expressions are
right associated, and it's hard to apply these lemmas about `colimit.Œπ`.

We thus use `reassoc` to define additional `@[simp]` lemmas, with an arbitrary extra morphism.
(see `tactic/reassoc_axiom.lean`)
 -/
@[simp, reassoc] lemma colimit.Œπ_desc {F : J ‚•§ C} [has_colimit F] (c : cocone F) (j : J) :
  colimit.Œπ F j ‚â´ colimit.desc F c = c.Œπ.app j :=
is_colimit.fac _ c j

/-- The cocone morphism from the chosen colimit cocone to any cocone. -/
def colimit.cocone_morphism {F : J ‚•§ C} [has_colimit F] (c : cocone F) :
  (colimit.cocone F) ‚ü∂ c :=
(colimit.is_colimit F).desc_cocone_morphism c

@[simp] lemma colimit.cocone_morphism_hom {F : J ‚•§ C} [has_colimit F] (c : cocone F) :
  (colimit.cocone_morphism c).hom = colimit.desc F c := rfl
lemma colimit.Œπ_cocone_morphism {F : J ‚•§ C} [has_colimit F] (c : cocone F) (j : J) :
  colimit.Œπ F j ‚â´ (colimit.cocone_morphism c).hom = c.Œπ.app j :=
by simp

@[ext] lemma colimit.hom_ext {F : J ‚•§ C} [has_colimit F] {X : C} {f f' : colimit F ‚ü∂ X}
  (w : ‚àÄ j, colimit.Œπ F j ‚â´ f = colimit.Œπ F j ‚â´ f') : f = f' :=
(colimit.is_colimit F).hom_ext w

/--
The isomorphism (in `Type`) between
morphisms from the colimit object to a specified object `W`,
and cocones with cone point `W`.
-/
def colimit.hom_iso (F : J ‚•§ C) [has_colimit F] (W : C) : (colimit F ‚ü∂ W) ‚âÖ (F.cocones.obj W) :=
(colimit.is_colimit F).hom_iso W

@[simp] lemma colimit.hom_iso_hom (F : J ‚•§ C) [has_colimit F] {W : C} (f : colimit F ‚ü∂ W) :
  (colimit.hom_iso F W).hom f = (colimit.cocone F).Œπ ‚â´ (const J).map f :=
(colimit.is_colimit F).hom_iso_hom f

/--
The isomorphism (in `Type`) between
morphisms from the colimit object to a specified object `W`,
and an explicit componentwise description of cocones with cone point `W`.
-/
def colimit.hom_iso' (F : J ‚•§ C) [has_colimit F] (W : C) :
  ((colimit F ‚ü∂ W) : Type v) ‚âÖ { p : Œ† j, F.obj j ‚ü∂ W // ‚àÄ {j j'} (f : j ‚ü∂ j'), F.map f ‚â´ p j' = p j } :=
(colimit.is_colimit F).hom_iso' W

lemma colimit.desc_extend (F : J ‚•§ C) [has_colimit F] (c : cocone F) {X : C} (f : c.X ‚ü∂ X) :
  colimit.desc F (c.extend f) = colimit.desc F c ‚â´ f :=
begin
  ext1, rw [‚Üêcategory.assoc], simp
end

/--
If we've chosen a colimit for a functor `F`,
we can transport that choice across a natural isomorphism.
-/
-- This has the isomorphism pointing in the opposite direction than in `has_limit_of_iso`.
-- This is intentional; it seems to help with elaboration.
def has_colimit_of_iso {F G : J ‚•§ C} [has_colimit F] (Œ± : G ‚âÖ F) : has_colimit G :=
{ cocone := (cocones.precompose Œ±.hom).obj (colimit.cocone F),
  is_colimit :=
  { desc := Œª s, colimit.desc F ((cocones.precompose Œ±.inv).obj s),
    fac' := Œª s j,
    begin
      rw [cocones.precompose_obj_Œπ, nat_trans.comp_app, colimit.cocone_Œπ],
      rw [category.assoc, colimit.Œπ_desc, ‚Üênat_iso.app_hom, ‚Üêiso.eq_inv_comp], refl
    end,
    uniq' := Œª s m w,
    begin
      apply colimit.hom_ext, intro j,
      rw [colimit.Œπ_desc, cocones.precompose_obj_Œπ, nat_trans.comp_app, ‚Üênat_iso.app_inv,
        iso.eq_inv_comp],
      simpa using w j
    end } }

/-- If a functor `G` has the same collection of cocones as a functor `F`
which has a colimit, then `G` also has a colimit. -/
def has_colimit.of_cocones_iso {J K : Type v} [small_category J] [small_category K] (F : J ‚•§ C) (G : K ‚•§ C)
  (h : F.cocones ‚âÖ G.cocones) [has_colimit F] : has_colimit G :=
‚ü®_, is_colimit.of_nat_iso ((is_colimit.nat_iso (colimit.is_colimit F)) ‚â™‚â´ h)‚ü©

section pre
variables (F) [has_colimit F] (E : K ‚•§ J) [has_colimit (E ‚ãô F)]

/--
The canonical morphism
from the chosen colimit of `E ‚ãô F`
to the chosen colimit of `F`.
-/
def colimit.pre : colimit (E ‚ãô F) ‚ü∂ colimit F :=
colimit.desc (E ‚ãô F)
  { X := colimit F,
    Œπ := { app := Œª k, colimit.Œπ F (E.obj k) } }

@[simp, reassoc] lemma colimit.Œπ_pre (k : K) : colimit.Œπ (E ‚ãô F) k ‚â´ colimit.pre F E = colimit.Œπ F (E.obj k) :=
by erw is_colimit.fac

@[simp] lemma colimit.pre_desc (c : cocone F) :
  colimit.pre F E ‚â´ colimit.desc F c = colimit.desc (E ‚ãô F) (c.whisker E) :=
by ext; rw [‚Üêassoc, colimit.Œπ_pre]; simp

variables {L : Type v} [small_category L]
variables (D : L ‚•§ K) [has_colimit (D ‚ãô E ‚ãô F)]

@[simp] lemma colimit.pre_pre : colimit.pre (E ‚ãô F) D ‚â´ colimit.pre F E = colimit.pre F (D ‚ãô E) :=
begin
  ext j,
  rw [‚Üêassoc, colimit.Œπ_pre, colimit.Œπ_pre],
  letI : has_colimit ((D ‚ãô E) ‚ãô F) := show has_colimit (D ‚ãô E ‚ãô F), by apply_instance,
  exact (colimit.Œπ_pre F (D ‚ãô E) j).symm
end

end pre

section post
variables {D : Type u'} [category.{v} D]

variables (F) [has_colimit F] (G : C ‚•§ D) [has_colimit (F ‚ãô G)]

/--
The canonical morphism
from `G` applied to the chosen colimit of `F ‚ãô G`
to `G` applied to the chosen colimit of `F`.
-/
def colimit.post : colimit (F ‚ãô G) ‚ü∂ G.obj (colimit F) :=
colimit.desc (F ‚ãô G)
{ X := G.obj (colimit F),
  Œπ :=
  { app := Œª j, G.map (colimit.Œπ F j),
    naturality' :=
      by intros j j' f; erw [‚ÜêG.map_comp, limits.cocone.w, comp_id]; refl } }

@[simp, reassoc] lemma colimit.Œπ_post (j : J) : colimit.Œπ (F ‚ãô G) j ‚â´ colimit.post F G  = G.map (colimit.Œπ F j) :=
by erw is_colimit.fac

@[simp] lemma colimit.post_desc (c : cocone F) :
  colimit.post F G ‚â´ G.map (colimit.desc F c) = colimit.desc (F ‚ãô G) (G.map_cocone c) :=
by ext; rw [‚Üêassoc, colimit.Œπ_post, ‚ÜêG.map_comp, colimit.Œπ_desc, colimit.Œπ_desc]; refl

@[simp] lemma colimit.post_post
  {E : Type u''} [category.{v} E] (H : D ‚•§ E) [has_colimit ((F ‚ãô G) ‚ãô H)] :
/- H G (colimit F) ‚ü∂ H (colimit (F ‚ãô G)) ‚ü∂ colimit ((F ‚ãô G) ‚ãô H) equals -/
/- H G (colimit F) ‚ü∂ colimit (F ‚ãô (G ‚ãô H)) -/
  colimit.post (F ‚ãô G) H ‚â´ H.map (colimit.post F G) = colimit.post F (G ‚ãô H) :=
begin
  ext,
  rw [‚Üêassoc, colimit.Œπ_post, ‚ÜêH.map_comp, colimit.Œπ_post],
  exact (colimit.Œπ_post F (G ‚ãô H) j).symm
end

end post

lemma colimit.pre_post {D : Type u'} [category.{v} D]
  (E : K ‚•§ J) (F : J ‚•§ C) (G : C ‚•§ D)
  [has_colimit F] [has_colimit (E ‚ãô F)] [has_colimit (F ‚ãô G)] [has_colimit ((E ‚ãô F) ‚ãô G)] :
/- G (colimit F) ‚ü∂ G (colimit (E ‚ãô F)) ‚ü∂ colimit ((E ‚ãô F) ‚ãô G) vs -/
/- G (colimit F) ‚ü∂ colimit F ‚ãô G ‚ü∂ colimit (E ‚ãô (F ‚ãô G)) or -/
  colimit.post (E ‚ãô F) G ‚â´ G.map (colimit.pre F E) = colimit.pre (F ‚ãô G) E ‚â´ colimit.post F G :=
begin
  ext,
  rw [‚Üêassoc, colimit.Œπ_post, ‚ÜêG.map_comp, colimit.Œπ_pre, ‚Üêassoc],
  letI : has_colimit (E ‚ãô F ‚ãô G) := show has_colimit ((E ‚ãô F) ‚ãô G), by apply_instance,
  erw [colimit.Œπ_pre (F ‚ãô G) E j, colimit.Œπ_post]
end

open category_theory.equivalence
instance has_colimit_equivalence_comp (e : K ‚âå J) [has_colimit F] : has_colimit (e.functor ‚ãô F) :=
{ cocone := cocone.whisker e.functor (colimit.cocone F),
  is_colimit := let e' := cocones.precompose (e.inv_fun_id_assoc F).inv in
  { desc := Œª s, colimit.desc F (e'.obj (cocone.whisker e.inverse s)),
    fac' := Œª s j,
    begin
      dsimp, rw [colimit.Œπ_desc], dsimp [e'],
      erw [inv_fun_id_assoc_inv_app, ‚Üêfunctor_unit, s.Œπ.naturality, comp_id], refl
    end,
    uniq' := Œª s m w,
    begin
      apply colimit.hom_ext, intro j,
      erw [colimit.Œπ_desc],
      have := w (e.inverse.obj j), simp at this, erw [‚Üêcolimit.w F (e.counit_iso.hom.app j)] at this,
      erw [assoc, ‚Üêiso.eq_inv_comp (F.map_iso $ e.counit_iso.app j)] at this, erw [this], simp
    end } }

/--
If a `E ‚ãô F` has a chosen colimit, and `E` is an equivalence, we can construct a chosen colimit of `F`.
-/
def has_colimit_of_equivalence_comp (e : K ‚âå J) [has_colimit (e.functor ‚ãô F)] : has_colimit F :=
begin
  haveI : has_colimit (e.inverse ‚ãô e.functor ‚ãô F) := limits.has_colimit_equivalence_comp e.symm,
  apply has_colimit_of_iso (e.inv_fun_id_assoc F).symm,
end

section colim_functor

variables [has_colimits_of_shape J C]

/-- `colimit F` is functorial in `F`, when `C` has all colimits of shape `J`. -/
def colim : (J ‚•§ C) ‚•§ C :=
{ obj := Œª F, colimit F,
  map := Œª F G Œ±, colimit.desc F
    { X := colimit G,
      Œπ :=
      { app := Œª j, Œ±.app j ‚â´ colimit.Œπ G j,
        naturality' := Œª j j' f,
          by erw [comp_id, ‚Üêassoc, Œ±.naturality, assoc, colimit.w] } },
  map_comp' := Œª F G H Œ± Œ≤,
    by ext; erw [‚Üêassoc, is_colimit.fac, is_colimit.fac, assoc, is_colimit.fac, ‚Üêassoc]; refl }

variables {F} {G : J ‚•§ C} (Œ± : F ‚ü∂ G)

@[simp, reassoc] lemma colimit.Œπ_map (j : J) : colimit.Œπ F j ‚â´ colim.map Œ± = Œ±.app j ‚â´ colimit.Œπ G j :=
by apply is_colimit.fac

@[simp] lemma colimit.map_desc (c : cocone G) :
  colim.map Œ± ‚â´ colimit.desc G c = colimit.desc F ((cocones.precompose Œ±).obj c) :=
by ext; rw [‚Üêassoc, colimit.Œπ_map, assoc, colimit.Œπ_desc, colimit.Œπ_desc]; refl

lemma colimit.pre_map [has_colimits_of_shape K C] (E : K ‚•§ J) :
  colimit.pre F E ‚â´ colim.map Œ± = colim.map (whisker_left E Œ±) ‚â´ colimit.pre G E :=
by ext; rw [‚Üêassoc, colimit.Œπ_pre, colimit.Œπ_map, ‚Üêassoc, colimit.Œπ_map, assoc, colimit.Œπ_pre]; refl

lemma colimit.pre_map' [has_colimits_of_shape.{v} K C]
  (F : J ‚•§ C) {E‚ÇÅ E‚ÇÇ : K ‚•§ J} (Œ± : E‚ÇÅ ‚ü∂ E‚ÇÇ) :
  colimit.pre F E‚ÇÅ = colim.map (whisker_right Œ± F) ‚â´ colimit.pre F E‚ÇÇ :=
by ext1; simp [‚Üê category.assoc]

lemma colimit.pre_id (F : J ‚•§ C) :
colimit.pre F (ùü≠ _) = colim.map (functor.left_unitor F).hom := by tidy

lemma colimit.map_post {D : Type u'} [category.{v} D] [has_colimits_of_shape J D] (H : C ‚•§ D) :
/- H (colimit F) ‚ü∂ H (colimit G) ‚ü∂ colimit (G ‚ãô H) vs
   H (colimit F) ‚ü∂ colimit (F ‚ãô H) ‚ü∂ colimit (G ‚ãô H) -/
  colimit.post F H ‚â´ H.map (colim.map Œ±) = colim.map (whisker_right Œ± H) ‚â´ colimit.post G H:=
begin
  ext,
  rw [‚Üêassoc, colimit.Œπ_post, ‚ÜêH.map_comp, colimit.Œπ_map, H.map_comp],
  rw [‚Üêassoc, colimit.Œπ_map, assoc, colimit.Œπ_post],
  refl
end

/--
The isomorphism between
morphisms from the cone point of the chosen colimit cocone for `F` to `W`
and cocones over `F` with cone point `W`
is natural in `F`.
-/
def colim_coyoneda : colim.op ‚ãô coyoneda ‚âÖ category_theory.cocones J C :=
nat_iso.of_components (Œª F, nat_iso.of_components (colimit.hom_iso (unop F)) (by tidy))
  (by tidy)

end colim_functor

/--
We can transport chosen colimits of shape `J` along an equivalence `J ‚âå J'`.
-/
def has_colimits_of_shape_of_equivalence {J' : Type v} [small_category J']
  (e : J ‚âå J') [has_colimits_of_shape J C] : has_colimits_of_shape J' C :=
by { constructor, intro F, apply has_colimit_of_equivalence_comp e, apply_instance }

end colimit

end category_theory.limits
